<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>忘归</title>
  
  <subtitle>愿得朱衣暗点头。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jalan.space/"/>
  <updated>2021-07-11T11:05:31.575Z</updated>
  <id>http://jalan.space/</id>
  
  <author>
    <name>Jalan.江佳扬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go 源码阅读：内存分配前的溢出判断</title>
    <link href="http://jalan.space/2021/07/11/2021/go-source-code-muluiniptr/"/>
    <id>http://jalan.space/2021/07/11/2021/go-source-code-muluiniptr/</id>
    <published>2021-07-11T11:01:00.000Z</published>
    <updated>2021-07-11T11:05:31.575Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看切片内存分配的源码，<code>makeslice</code> 函数在内存分配前先使用 <code>MaxUintptr</code> 函数来判断内存分配是否越界：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func makeslice(et *_type, len, cap int) unsafe.Pointer &#123;</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, uintptr(cap))</span><br><span class="line">if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap &#123;</span><br><span class="line">// 先判断是否越界</span><br><span class="line">mem, overflow := math.MulUintptr(et.size, uintptr(len))</span><br><span class="line">if overflow || mem &gt; maxAlloc || len &lt; 0 &#123;</span><br><span class="line">panicmakeslicelen()</span><br><span class="line">&#125;</span><br><span class="line">panicmakeslicecap()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 内存分配</span><br><span class="line">return mallocgc(mem, et, true)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出于好奇看了一下 <code>MaxUintptr</code> 的源码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2018 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"runtime/internal/sys"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MaxUintptr = ^<span class="keyword">uintptr</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// MulUintptr returns a * b and whether the multiplication overflowed.</span></span><br><span class="line"><span class="comment">// On supported platforms this is an intrinsic lowered by the compiler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MulUintptr</span><span class="params">(a, b <span class="keyword">uintptr</span>)</span> <span class="params">(<span class="keyword">uintptr</span>, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a|b &lt; <span class="number">1</span>&lt;&lt;(<span class="number">4</span>*sys.PtrSize) || a == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * b, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">overflow := b &gt; MaxUintptr/a</span><br><span class="line"><span class="keyword">return</span> a * b, overflow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，<code>MulUintptr</code> 接收两个参数，分别是要分配的类型大小 <code>a</code> 和要分配的数量 <code>b</code>，计算后返回要分配的内存空间以及是否溢出。</p><h2 id="位运算表达式的含义"><a href="#位运算表达式的含义" class="headerlink" title="位运算表达式的含义"></a>位运算表达式的含义</h2><p><code>a|b &lt; 1&lt;&lt;(4*sys.PtrSize)</code> 这个位运算表达式看起来非常复杂，我们来剖析一下。</p><p><code>sys.PtrSize</code> 表示系统指针大小，在 32 位机器中，<code>sys.PtrSize = 4</code>，64 位机器中，<code>sys.PtrSize = 8</code>。<code>&lt;&lt;</code> 是左移运算符，我们知道在运算中左移 1 位就是一次乘 2 操作，因此 <code>1&lt;&lt;(4*sys.PtrSize)</code> 表示的其实就是 <code>2^(4*sys.PtrSize)</code>。</p><p>综上，我们可以把表达式变形一下：</p><ul><li>在 32 位机器中，<code>4*sys.PtrSize = 4 * 4 = 16</code> 表达式可以写作 <code>a|b &lt; 2^16</code>，可证明 <code>a</code> 与 <code>b</code> 均小于 2^16，<code>a * b</code> 必然小于 2^32</li><li>在 64 位机器中，<code>4*sys.PtrSize = 4 * 8 = 32</code> 表达式可以写作 <code>a|b &lt; 2^32</code>，可证明 <code>a</code> 与 <code>b</code> 均小于 2^32，<code>a * b</code> 必然小于 2^64</li></ul><p>那么 2^32 与 2^64 又代表着什么呢？</p><h2 id="何为溢出？"><a href="#何为溢出？" class="headerlink" title="何为溢出？"></a>何为溢出？</h2><p>我们常说的 64 位系统或 32 位系统，其中的「位数」决定了计算机的<strong>寻址空间</strong>，即 CPU 对于内存的寻址能力。通俗地讲，就是 CPU 最多能够使用的内存。32 位系统的寻址空间为 2^32，64 位系统的寻址空间为 2^64。</p><p>因此，<code>a|b &lt; 1&lt;&lt;(4*sys.PtrSize)</code> 的含义是：<strong>要分配的内存是否小于寻址空间</strong>。若小于寻址空间，即不存在溢出，此时函数返回 <code>overflow = false</code>。</p><h2 id="uintptr-0-是什么？"><a href="#uintptr-0-是什么？" class="headerlink" title="^uintptr(0) 是什么？"></a><code>^uintptr(0)</code> 是什么？</h2><p><code>unintptr</code> 是 Go 中的自定义整型：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifdef _64BIT</span><br><span class="line">typedef    uint64        uintptr;</span><br><span class="line">#else</span><br><span class="line">typedef    uint32        uintptr;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><ul><li>32 位系统中，<code>unitptr</code> 代表 <code>uint32</code>，占 4 字节，<code>^uintptr(0)</code> 等于 <code>^uint32(0)</code>，即 2^32 - 1</li><li>64 位系统中，<code>unitptr</code> 代表 <code>uint64</code>，占 8 字节，<code>^uintptr(0)</code> 等于 <code>^uint64(0)</code>，即 2^64 - 1</li></ul><p>因此，<code>overflow := b &gt; MaxUintptr/a</code> 可以变形为：</p><ul><li>在 32 位机器中：<code>overflow := b &gt; (2^32 - 1)/a</code></li><li>在 64 位机器中：<code>overflow := b &gt; (2^64 - 1)/a</code></li></ul><p>这样就很好理解啦。</p><h2 id="代码逻辑思考"><a href="#代码逻辑思考" class="headerlink" title="代码逻辑思考"></a>代码逻辑思考</h2><p>如果由我来写这段代码，我无法想到这样的写法，大概率会使用 <code>a * b &lt; MaxUintptr</code> 来暴力解决问题。然而计算机中乘法与除法并不意味着更快的计算过程，他们的本质还是使用累加器，而位运算才意味着高效。因此，先使用 <code>a|b &lt; 1&lt;&lt;(4*sys.PtrSize)</code> 作为判断是非常巧妙的做法。</p><h2 id="存在的疑问"><a href="#存在的疑问" class="headerlink" title="存在的疑问"></a>存在的疑问</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> a|b &lt; <span class="number">1</span>&lt;&lt;(<span class="number">4</span>*sys.PtrSize) || a == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * b, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我对以上这句逻辑判断存在疑问，根据短路求值，把 <code>a == 0</code> 写在前面是否更好呢？以及是否需要把 <code>b == 0</code> 也补上？准备提个 issue 问问开发者吧。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/golang/go/blob/feb984c96b10900daade4b47c4d308d7dd4ed5c3/src/runtime/internal/math/math.go#L13" target="_blank" rel="noopener">MulUintptr 源码</a></li><li><a href="https://segmentfault.com/a/1190000017783070" target="_blank" rel="noopener">Go Slice 最大容量大小是怎么来的</a></li></ul>]]></content>
    
    <summary type="html">
    
      MaxUintptr 函数干了哪些活？
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Go" scheme="http://jalan.space/tags/Go/"/>
    
      <category term="源码阅读" scheme="http://jalan.space/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>【译】给初学者的示例：什么是 WSGI？</title>
    <link href="http://jalan.space/2020/11/19/2020/what-is-wsgi/"/>
    <id>http://jalan.space/2020/11/19/2020/what-is-wsgi/</id>
    <published>2020-11-19T12:37:00.000Z</published>
    <updated>2021-01-19T11:45:01.724Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://levelup.gitconnected.com/demoforbeginner-what-is-wsgi-ac3c2a67089" target="_blank" rel="noopener">DemoForBeginner: What is WSGI?</a></li><li>原文作者：<a href="https://medium.com/@zosionlee.chou" target="_blank" rel="noopener">Zosionlee</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2020/demoforbeginner-what-is-wsgi.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/article/2020/demoforbeginner-what-is-wsgi.md</a></li><li>译者：<a href="http://jalan.space/">JalanJiang</a></li><li>校对者：</li></ul></blockquote><h1 id="给初学者的示例-什么是-WSGI？"><a href="#给初学者的示例-什么是-WSGI？" class="headerlink" title="给初学者的示例: 什么是 WSGI？"></a>给初学者的示例: 什么是 WSGI？</h1><p>PEP-3333 详细描述了 WSGI 协议规范。WSGI 是 Python Web Server Gateway Interface（Python 服务器网关协议）的缩写，是一个描述如何在 Web 服务器与 Python 应用之间交互的接口规范。因此，我们将讨论并理解如何以代码的形式实现 WSGI 协议。你可以在我的 GitHub 仓库中获得所有的源码。</p><p><img src="https://cdn-images-1.medium.com/max/3314/1*PHVAYtkTLNcEl-OqhpsUUA.png" alt=""></p><p>让我们一起来探讨应用程序与服务器吧。</p><h4 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h4><ul><li>应用程序是可调用的，它有且仅接收两个参数，例如 <code>application(environ, start_response)</code>。并且这两个参数只能作为位置参数传入。</li><li>应用程序必须被多次调用，因为所有的服务器/网关（除了 CGI）都将发出这种重复的请求。</li><li><code>environ</code> 是一个字典参数，它包含 CGI 风格的环境变量。它必须使用 Python 内置的字典类型，并允许应用程序以任何方式修改它。字典还包括某些 WSGI 变量，它的命名需要符合相应的规范，例如：</li></ul><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">environ = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> os.environ.items()&#125;</span><br><span class="line">environ[<span class="string">'wsgi.input'</span>] = self.rfile</span><br><span class="line">environ[<span class="string">'wsgi.errors'</span>] = sys.stderr</span><br><span class="line">environ[<span class="string">'wsgi.version'</span>] = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">environ[<span class="string">'wsgi.multithread'</span>] = <span class="keyword">False</span></span><br><span class="line">environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="keyword">True</span></span><br><span class="line">environ[<span class="string">'wsgi.run_once'</span>] = <span class="keyword">True</span></span><br><span class="line">environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></span><br></pre></td></tr></table></figure><ul><li><code>start_response</code> 参数也是一个可调用参数，它接收两个必须的未知的参数（<code>status</code> 和 <code>response_header</code>）和一个可选参数（<code>exc_info=None</code>）。<code>status</code> 是一个 HTTP 状态字符串，<code>response_headers</code> 是一个描述了 HTTP 响应头部（<code>header_name</code>，<code>header_value</code>）的元组列表。</li><li><code>start_response</code> 必须返回一个 callable，这个 callable 需要一个位置参数：一个二进制字符串作为 HTTP 响应的主体。</li><li>如果应用程序返回的迭代对象拥有一个关闭方法，则无论请求是否正常完成，服务器必须在当前请求结束后调用该方法。</li></ul><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ul><li>接收 HTTP 请求并返回 HTTP 响应。</li><li>提供 <code>environ</code> 数据并执行回调函数 <code>start_response</code>。</li><li>调用 WSGI 应用程序并传递 <code>environ</code> 和 <code>start_response</code> 参数。</li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><p>对于某些应用程序，单个对象可能扮演着服务器的角色，同时也可以作为某些服务器相关的应用程序。WSGI 应用程序相当于 WSGI 服务器，WSGI 服务器又等效于 WSGI 应用程序。</p><h4 id="让我们手写一个示例代码"><a href="#让我们手写一个示例代码" class="headerlink" title="让我们手写一个示例代码"></a>让我们手写一个示例代码</h4><p>所有手写代码都在我的 <a href="https://github.com/ZosionLee/DemoForBeginner/blob/develop/wsgi/wsgi_handwrite.py" target="_blank" rel="noopener">GitHub 仓库</a> 中，代码如下所示：</p><h4 id="应用程序-1"><a href="#应用程序-1" class="headerlink" title="应用程序"></a>应用程序</h4><p>以下列出执行应用程序的三种方式：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">'''通过定义函数实现应用程序'''</span></span><br><span class="line"></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain; charset=utf-8'</span>)]</span><br><span class="line">    start_response(status, headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'hello,world\n'</span>.encode(<span class="string">'utf-8'</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IterSimpleApp</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''可迭代类'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start_response = start_response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [</span><br><span class="line">            (<span class="string">'Content-type'</span>, <span class="string">'text/plain; charset=utf-8'</span>)</span><br><span class="line">        ]</span><br><span class="line">        self.start_response(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello,world\n'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InstSimpleApp</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''可调用实例'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [</span><br><span class="line">            (<span class="string">'Content-type'</span>, <span class="string">'text/plain; charset=utf-8'</span>),</span><br><span class="line">        ]</span><br><span class="line">        start_response(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello,world\n'</span>.encode(<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure><h4 id="中间件-1"><a href="#中间件-1" class="headerlink" title="中间件"></a>中间件</h4><p>一个用于认证的中间件示例代码如下所示：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthMiddleware</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">'''用于认证过滤的中间件示例'''</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,app)</span>:</span></span><br><span class="line">        self.app=app</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self,environ,start_response)</span>:</span></span><br><span class="line">        auth = environ.get(<span class="string">'wsgi.authentication'</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> auth != <span class="string">'zosionlee'</span>:</span><br><span class="line">            start_response(</span><br><span class="line">                <span class="string">'403 Forbidden'</span>,</span><br><span class="line">                [(<span class="string">'Content-Type'</span>, <span class="string">'text/plain; charset=utf-8'</span>)]</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span> [</span><br><span class="line">                <span class="string">'No authentication, forbidden.\n'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line">            ]</span><br><span class="line">        <span class="keyword">return</span> self.app(environ, start_response)</span><br></pre></td></tr></table></figure><h4 id="服务器-1"><a href="#服务器-1" class="headerlink" title="服务器"></a>服务器</h4><p>自定义服务器模块比较复杂，主要使用了下列 Python 原生库：</p><ul><li>使用 <code>os</code> 模块获取 <code>environ</code>。</li><li>使用 <code>sys</code> 来设置错误输出。</li><li>通过事件循环实现 IO 多路复用的选择器。</li><li>使用 socket 通信。</li></ul><p><img src="https://cdn-images-1.medium.com/max/3702/1*wKZbKXmlXr-dx9QaXgI20w.png" alt=""></p><p>关于定制服务器，实际上 Python 实现了一个 WSGI 协议库，用于在开发环境中使用，例如 wsgiref。我在这里阐述服务器只是为了方便你更好地理解 WSGI 服务器是如何实现的。</p><h4 id="让我们来看看-wsgiref"><a href="#让我们来看看-wsgiref" class="headerlink" title="让我们来看看 wsgiref"></a>让我们来看看 wsgiref</h4><p>wsgiref 基于 <strong>socketserver</strong> 库，所以让我们先来看看 socketserver。</p><p>socketserver 的类图如下：</p><p><img src="https://cdn-images-1.medium.com/max/3726/1*ZeEVOdTcTBdMtF7huJydow.png" alt=""></p><p>基于对 socketserver 的分析和理解，wsgiref 是这样实现 WSGI 协议的： </p><p><img src="https://cdn-images-1.medium.com/max/3776/1*kI7Xtyw0pzpv6BjpVEsNHg.png" alt=""></p><h4 id="让我们总结一下"><a href="#让我们总结一下" class="headerlink" title="让我们总结一下"></a>让我们总结一下</h4><ul><li>PEP-3333 详细描述了 WSGI。</li><li>我们已经讨论了 WSGI 服务器与应用程序。</li><li>我们大致地看了 wsgiref，并了解了 WSGIServer 和 WSGIRequestHandler 的交互过程。</li><li>根据 WSGI 协议的描述，我们手写代码实现了应用程序与服务器。</li></ul><p>这就是文章的所有内容，希望它对你有所帮助。如果你喜欢这篇原创文章，请点击 claps。欢迎留言。谢谢。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      WSGI 协议规范
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="翻译" scheme="http://jalan.space/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="网络" scheme="http://jalan.space/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序自定义 tabBar 踩坑实践</title>
    <link href="http://jalan.space/2020/10/30/2020/wx-miniprogram-tabbar/"/>
    <id>http://jalan.space/2020/10/30/2020/wx-miniprogram-tabbar/</id>
    <published>2020-10-30T12:37:00.000Z</published>
    <updated>2021-01-19T11:42:41.056Z</updated>
    
    <content type="html"><![CDATA[<p>微信<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html?search-key=%E8%87%AA%E5%AE%9A%E4%B9%89tabbar" target="_blank" rel="noopener">官方文档</a>对自定义 tabBar 的阐述较为潦草，在开发自定义 tabBar 过程中我踩了很多坑，因此在此处做个总结。</p><p>我使用 <a href="https://vant-contrib.gitee.io/vant-weapp/#/intro" target="_blank" rel="noopener">Vant Weapp</a> 作为 UI 组件库，下面以此组件库为例。</p><h2 id="定义-tabBar"><a href="#定义-tabBar" class="headerlink" title="定义 tabBar"></a>定义 tabBar</h2><h3 id="创建自定义-tabBar-文件"><a href="#创建自定义-tabBar-文件" class="headerlink" title="创建自定义 tabBar 文件"></a>创建自定义 tabBar 文件</h3><p>创建一个与 <em>/pages</em> 的<strong>同级</strong>目录，命名为  <em>/custom-tab-bar</em>，注意目录层级与目录命名问题，不可用其他名称命名。</p><p>在 <em>/custom-tab-bar</em> 下创建四个文件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index.js</span><br><span class="line">index.json</span><br><span class="line">index.wxml</span><br><span class="line">index.wxss</span><br></pre></td></tr></table></figure><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><p>在 <em>index.js</em> 中我们定义相关数据：</p><ul><li><code>active</code>：当前被点击 tab 的索引</li><li><code>list</code>：tab 列表</li></ul><p>以及一个切换 tab 时触发的方法：</p><ul><li><code>function onChange(event)</code>：标签切换时触发，修改 <code>active</code> 值，点亮被点击的 tab 并进行页面跳转</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Component(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    <span class="comment">// 选中的 tab </span></span><br><span class="line">    active: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 菜单列表</span></span><br><span class="line">    list: [</span><br><span class="line">      &#123;</span><br><span class="line">        pagePath: <span class="string">'/pages/subscriptions/subscriptions'</span>,</span><br><span class="line">        text: <span class="string">'订阅'</span>,</span><br><span class="line">        name: <span class="string">'subscriptions'</span>,</span><br><span class="line">        icon: <span class="string">'bullhorn-o'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        pagePath: <span class="string">'/pages/profile/profile'</span>,</span><br><span class="line">        text: <span class="string">'我的'</span>,</span><br><span class="line">        name: <span class="string">'profile'</span>,</span><br><span class="line">        icon: <span class="string">'user-o'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">// 标签切换</span></span><br><span class="line">    onChange: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.setData(&#123; <span class="attr">active</span>: event.detail &#125;)</span><br><span class="line">      wx.switchTab(&#123;</span><br><span class="line">        url: <span class="keyword">this</span>.data.list[event.detail].pagePath,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="index-json"><a href="#index-json" class="headerlink" title="index.json"></a>index.json</h4><p>在 <em>index.json</em> 中，将 <code>component</code> 参数值设为 <code>true</code>，代表这是一个自定义组件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我使用了 <a href="https://vant-contrib.gitee.io/vant-weapp/#/intro" target="_blank" rel="noopener">Vant Weapp</a> 的 <a href="https://vant-contrib.gitee.io/vant-weapp/#/tabbar" target="_blank" rel="noopener">tabBar 标签栏</a>，所以还需引入额外组件：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"component"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"usingComponents"</span>: &#123;</span><br><span class="line">    <span class="attr">"van-tabbar"</span>: <span class="string">"@vant/weapp/tabbar/index"</span>,</span><br><span class="line">    <span class="attr">"van-tabbar-item"</span>: <span class="string">"@vant/weapp/tabbar-item/index"</span>,</span><br><span class="line">    <span class="attr">"van-icon"</span>: <span class="string">"@vant/weapp/icon/index"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="index-wxml"><a href="#index-wxml" class="headerlink" title="index.wxml"></a>index.wxml</h4><p>在 <em>index.wxml</em> 中定义组件形态，我在此处使用 <a href="https://vant-contrib.gitee.io/vant-weapp/#/intro" target="_blank" rel="noopener">Vant Weapp</a> 的 <a href="https://vant-contrib.gitee.io/vant-weapp/#/tabbar" target="_blank" rel="noopener">tabBar 标签栏</a>，详见代码，不再赘述。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">van-tabbar</span> <span class="attr">active</span>=<span class="string">"&#123;&#123; active &#125;&#125;"</span> <span class="attr">bind:change</span>=<span class="string">"onChange"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">van-tabbar-item</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">wx:for</span>=<span class="string">"&#123;&#123;list&#125;&#125;"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">wx:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">icon</span>=<span class="string">"&#123;&#123;item.icon&#125;&#125;"</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">data-path</span>=<span class="string">"&#123;&#123;item.pagePath&#125;&#125;"</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.text&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">van-tabbar-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">van-tabbar</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置-app-json"><a href="#配置-app-json" class="headerlink" title="配置 app.json"></a>配置 app.json</h3><p>在 <em>app.json</em> 中配置如下参数：</p><ul><li><code>usingComponents</code>：仅声明即可</li><li><code>tabBar</code>：tabBar 组件的具体配置<ul><li><code>custom</code>：设为 <code>true</code>，表示使用自定义组件</li><li><code>list</code>：tab 页列表，在列表中的页面将被设置为 tab 页，自动加载 tabBar</li></ul></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"usingComponents"</span>:&#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"tabBar"</span>:&#123;</span><br><span class="line">        <span class="attr">"custom"</span>:<span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"color"</span>:<span class="string">"#000000"</span>,</span><br><span class="line">        <span class="attr">"selectedColor"</span>:<span class="string">"#000000"</span>,</span><br><span class="line">        <span class="attr">"backgroundColor"</span>:<span class="string">"#000000"</span>,</span><br><span class="line">        <span class="attr">"list"</span>:[</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pagePath"</span>:<span class="string">"pages/subscriptions/subscriptions"</span>,</span><br><span class="line">                <span class="attr">"text"</span>:<span class="string">"订阅列表"</span>,</span><br><span class="line">                <span class="attr">"iconPath"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"selectedIconPath"</span>:<span class="string">""</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">"pagePath"</span>:<span class="string">"pages/profile/profile"</span>,</span><br><span class="line">                <span class="attr">"text"</span>:<span class="string">"关于我"</span>,</span><br><span class="line">                <span class="attr">"iconPath"</span>:<span class="string">""</span>,</span><br><span class="line">                <span class="attr">"selectedIconPath"</span>:<span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-tabBar-选中态"><a href="#实现-tabBar-选中态" class="headerlink" title="实现 tabBar 选中态"></a>实现 tabBar 选中态</h3><p>根据微信官方文档描述，每个 tab 页面 tabBar 的实例是不同的：</p><blockquote><p>每个 tab 页下的自定义 tabBar 组件实例是不同的，可通过自定义组件下的 getTabBar 接口，获取当前页面的自定义 tabBar 组件实例。</p></blockquote><p>显而易见，每当切换 tab 页时，我们都需要更新 tabBar 的选中态。关于选中态的实现，官方文档描述如下：</p><blockquote><p>注意：如需实现 tab 选中态，要在当前页面下，通过 getTabBar 接口获取组件实例，并调用 setData 更新选中态。</p></blockquote><p>我们可以在使用到 tabBar 的页面中这样实现：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Page(&#123;</span><br><span class="line">  onShow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.getTabBar === <span class="string">'function'</span> &amp;&amp; <span class="keyword">this</span>.getTabBar()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getTabBar().setData(&#123;</span><br><span class="line">        <span class="comment">// 当前页面的 tabBar 索引</span></span><br><span class="line">        active: <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p>至此，一个自定义 tabBar 的实现已全部完成。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="getTabBar-方法缺失"><a href="#getTabBar-方法缺失" class="headerlink" title="getTabBar() 方法缺失"></a>getTabBar() 方法缺失</h3><p>在实现 tabBar 选中态时遇到 <code>getTabBar()</code> 方法缺失的问题。在小程序开发工具中跳转到 <code>getTabBar()</code> 方法的定义，我们可以看到：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 返回当前页面的 custom-tab-bar 的组件实例</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 最低基础库版本：[`2.6.2`](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">getTabBar(): TrivialInstance</span><br></pre></td></tr></table></figure><p>该方法的最低基础版本库为 2.6.2，我们修改 <em>project.config.json</em> 文件中的 <code>libVersion</code> 字段，升级到指定版本库即可。</p><h3 id="升级版本库后-tabBar-组件报错"><a href="#升级版本库后-tabBar-组件报错" class="headerlink" title="升级版本库后 tabBar 组件报错"></a>升级版本库后 tabBar 组件报错</h3><p>报错内容如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Component is not found in path &quot;custom-tab-bar/index&quot;</span><br></pre></td></tr></table></figure><p>该原因是由于 tabBar 组件目录放置错误导致的，需要注意以下几点：</p><ol><li>目录需与 <em>/pages</em> 同级</li><li>目录名称是 <em>custom-tab-bar</em></li><li>目录下所包含的文件名为 <em>index.后缀</em></li><li>在 <em>app.json</em> 配置中，<code>tabBar</code> 下的 <code>custom</code> 字段需设置为 <code>true</code></li></ol><h3 id="getTabBar-始终返回-null"><a href="#getTabBar-始终返回-null" class="headerlink" title="getTabBar() 始终返回 null"></a>getTabBar() 始终返回 null</h3><p>依旧是目录放置与文件命名问题，处理方法同上。</p><p>另外，不需要在 <em>app.json</em> 的 <code>usingComponents</code> 引入 tabBar 组件，如果你放置目录与命名正确，小程序会自动引入。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/ability/custom-tabbar.html?search-key=%E8%87%AA%E5%AE%9A%E4%B9%89tabbar" target="_blank" rel="noopener">小程序官方文档：自定义 tabBar</a></li><li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000c8a90478030226cf98ea3751013" target="_blank" rel="noopener">官方自定义 tabbar 的显示和隐藏</a></li><li><a href="https://developers.weixin.qq.com/community/develop/doc/000cc43f5d03a831686af950a51400?_at=tdjfeehau" target="_blank" rel="noopener">使用自定义 tabbar,在 tab 页中使用 this.getTabBar() 一直返回 null，什么原因？</a></li><li><a href="https://developers.weixin.qq.com/community/develop/doc/000c0a0ea183404283481066e5b400" target="_blank" rel="noopener">getTabBar 无法调用 接口相关说明在哪里？</a></li></ul><hr><blockquote><p>欢迎关注公众号「<strong>编程拯救世界</strong>」，来技术世界一起冒险成长~</p></blockquote>]]></content>
    
    <summary type="html">
    
      开发自定义 tabBar 的踩坑总结
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="前端" scheme="http://jalan.space/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="小程序" scheme="http://jalan.space/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【译】Golang 切片综合指南</title>
    <link href="http://jalan.space/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/"/>
    <id>http://jalan.space/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/</id>
    <published>2020-10-14T12:37:00.000Z</published>
    <updated>2021-01-19T11:39:21.933Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://codeburst.io/a-comprehensive-guide-to-slices-in-golang-bacebfe46669" target="_blank" rel="noopener">A Comprehensive Guide to Slices in Golang</a></li><li>原文作者：<a href="https://medium.com/@rksurwase" target="_blank" rel="noopener">Radhakishan Surwase</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2020/a-comprehensive-guide-to-slices-in-golang.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/article/2020/a-comprehensive-guide-to-slices-in-golang.md</a></li><li>译者：<a href="http://jalan.space/">JalanJiang</a></li><li>校对者：<a href="https://github.com/Eminlin" target="_blank" rel="noopener">Emin</a>，<a href="https://github.com/suhanyujie" target="_blank" rel="noopener">Samuel Jie</a></li></ul></blockquote><h1 id="Golang-切片综合指南"><a href="#Golang-切片综合指南" class="headerlink" title="Golang 切片综合指南"></a>Golang 切片综合指南</h1><p><img src="https://cdn-images-1.medium.com/max/12000/1*i7lsjZyVnJxDEIg8Qibdlw.jpeg" alt="由于 [Paweł Czerwiński](https://unsplash.com/@pawel_czerwinski) 拍摄于 [Unsplash](https://unsplash.com/s/photos/array)"></p><p>在这篇文章中，我们将复习「切片」的概念，它是 Golang 中一个重要的数据结构，这一数据结构为你提供了处理与管理数据集合的方法。切片是围绕着动态数组的概念构建的，它与动态数组相似，可以根据你的需要而伸缩。</p><ul><li>就增长而言，切片是<strong>动态</strong>的，因为它们有自己的内置函数 <strong>append</strong>，可以快速高效地增长切片。</li><li>你还可以通过切割底层内存来减少切片的大小。</li><li>在底层内存中切片是在连续的块上分配的，因此切片为你提供的便利之处包括：索引、迭代与垃圾回收优化。</li></ul><h4 id="切片的表示"><a href="#切片的表示" class="headerlink" title="切片的表示"></a>切片的表示</h4><ul><li>切片不存储任何数据，它仅描述底层数组的一部分。</li><li>切片使用一个包含三个字段的结构表示：指向底层数组的指针（pointer）、长度（length）与容量（capacity）。</li><li>这个数据结构类似于切片的描述符。</li></ul><p><img src="https://cdn-images-1.medium.com/max/2000/1*PW4Y8P0_gTspgYwcxfDrtQ.png" alt="图 1：切片的表示"></p><ul><li><strong>指针（Pointer）：</strong>指针用于指向数组的第一个元素，这个元素可以通过切片进行访问。在这里，指向的元素不必是数组的第一个元素。</li><li><strong>长度（Length）：</strong>长度代表数组中所有元素的总数。</li><li><strong>容量（Capacity）：</strong>容量表示切片可扩展的最大大小。 </li></ul><h4 id="使用长度声明一个切片"><a href="#使用长度声明一个切片" class="headerlink" title="使用长度声明一个切片"></a>使用长度声明一个切片</h4><p>在声明切片过程中，当你仅指定长度（Length）时，容量（Capacity）值与长度（Length）值相同。</p><p><img src="https://cdn-images-1.medium.com/max/2000/1*5ssbGNTliiFWF_rcxN6RRg.png" alt="图 2：使用长度声明一个切片。"></p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用长度声明一个切片。创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br></pre></td></tr></table></figure><h4 id="使用长度和容量声明一个切片"><a href="#使用长度和容量声明一个切片" class="headerlink" title="使用长度和容量声明一个切片"></a>使用长度和容量声明一个切片</h4><p>在声明切片过程中，当你分别指定长度（Length）和容量（Capacity）时，这将初始化一段无法访问的底层数组来创建一个具有可用容量的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 使用长度和容量声明一个切片</span></span><br><span class="line"><span class="comment"> 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度为 3，容量为 5 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*6OLPqO2Z2x-QKPU_9EDA2A.png" alt="图 3：使用长度和容量声明一个切片。"></p><p>但请注意，尝试创建容量小于长度的切片是不允许的。</p><h4 id="使用切片字面量创建切片"><a href="#使用切片字面量创建切片" class="headerlink" title="使用切片字面量创建切片"></a>使用切片字面量创建切片</h4><p>创建<strong>切片</strong>的惯用方法是使用<strong>切片字面量</strong>。它与创建数组相似，只是它不需要在 [ ] 操作符中指定值。你初始化切片时所用元素的数量将决定切片的初始长度与容量。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串类型切片。</span></span><br><span class="line"><span class="comment">// 长度与容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>&#125; </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度与容量均为 3。</span></span><br><span class="line">intSlice:= []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(intSlice)) <span class="comment">// 打印结果 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(intSlice)) <span class="comment">// 打印结果 3</span></span><br></pre></td></tr></table></figure><h4 id="声明一个带有索引位置的切片"><a href="#声明一个带有索引位置的切片" class="headerlink" title="声明一个带有索引位置的切片"></a>声明一个带有索引位置的切片</h4><p>当使用切片<strong>字面量</strong>时，你可以初始化切片的<strong>长度</strong>与<strong>容量</strong>。你所需要做的就是初始化表示所需长度和容量的<strong>索引</strong>。下面的语法将创建一个长度和容量均为 100 的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串类型切片。</span></span><br><span class="line"><span class="comment">// 用空字符串初始化第 100 个元素。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">88</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) </span><br><span class="line"><span class="comment">// 打印结果 100</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) </span><br><span class="line"><span class="comment">// 打印结果 100</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*nG722TP5WDx3hZOHBpcFyQ.png" alt="图 4: 声明一个带有索引位置的切片。"></p><h4 id="声明数组与切片的区别"><a href="#声明数组与切片的区别" class="headerlink" title="声明数组与切片的区别"></a>声明数组与切片的区别</h4><ul><li>如果你使用 [ ] 操作符中指定一个值，那么你在创建一个数组。</li><li>如果你不在 [ ] 中指定值，则创建一个切片。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含 3 个整数的数组。</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度和容量均为 3 的整型切片。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="声明一个-nil-切片"><a href="#声明一个-nil-切片" class="headerlink" title="声明一个 nil 切片"></a>声明一个 nil 切片</h4><ul><li>切片用 <code>nil</code> 代表零值。</li><li>一个 nil 切片的长度和容量等于 0，且没有底层数组。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型 nil 切片。</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int32</span></span><br><span class="line">fmt.Println(slice == <span class="literal">nil</span>) </span><br><span class="line"><span class="comment">// 此行将打印 true</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))   </span><br><span class="line"><span class="comment">// 此行将打印 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line"><span class="comment">// 此行将打印 0</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*2KWa4gM4_M_47eBcKISK9w.png" alt="图 5：声明 nil 切片。"></p><h4 id="声明一个空切片"><a href="#声明一个空切片" class="headerlink" title="声明一个空切片"></a>声明一个空切片</h4><p>还可以通过初始化声明切片创建一个空切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 make 来创建一个整型空切片。</span></span><br><span class="line">sliceOne := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 使用切片字面量创建一个整型空切片。</span></span><br><span class="line">sliceTwo := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(sliceOne == <span class="literal">nil</span>) <span class="comment">// 这将打印 false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sliceOne))   <span class="comment">// 这将打印 0 </span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(sliceOne))   <span class="comment">// 这将打印 0</span></span><br><span class="line">fmt.Println(sliceTwo == <span class="literal">nil</span>) <span class="comment">// 这将打印 false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sliceTwo))   <span class="comment">// 这将打印 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(sliceTwo))   <span class="comment">// 这将打印 0</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*x3dfcqD71X5M0G2F4D7QoQ.png" alt="图 6：声明一个空切片。"></p><h4 id="为任何特定索引赋值"><a href="#为任何特定索引赋值" class="headerlink" title="为任何特定索引赋值"></a>为任何特定索引赋值</h4><p>要修改单个元素的值，请使用 [ ] 操作符。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 包含 4 个元素的长度和容量。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">fmt.Println(slice) <span class="comment">// 这将打印 [10 20 30 40]</span></span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">25</span> <span class="comment">// 改变索引 1 的值。</span></span><br><span class="line">fmt.Println(slice) <span class="comment">// 这将打印 [10 25 30 40]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*E-LTi2XYMjW0m5RGwzfktQ.png" alt="图 7：为任何特定索引赋值。"></p><h4 id="对切片进行切片"><a href="#对切片进行切片" class="headerlink" title="对切片进行切片"></a>对切片进行切片</h4><p>我们之所以称呼切片为切片，是因为你可以通过对底层数组的一部分进行切片来创建一个新的切片。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个整型切片。</span></span><br><span class="line"><span class="comment">长度和容量均为 5。*/</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">fmt.Println(slice)  <span class="comment">// 打印 [10 20 30 40 50]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印 5</span></span><br><span class="line"><span class="comment">/* 创建一个新切片。</span></span><br><span class="line"><span class="comment">长度为 2，容量为 4。*/</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(slice)  <span class="comment">// 打印 [10 20 30 40 50]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice))  <span class="comment">// 打印 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice))  <span class="comment">// 打印 4</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*7g5CJ002CXIEo9iQn-Dp6A.png" alt="图 8：对切片进行切片。"></p><p>在执行切片操作之后，我们拥有两个共享同一底层数组的切片。然而，这两个切片以不同的方式查看底层数组。原始切片认为底层数组的容量为 5，但 newSlice 与之不同，对 newSlice 而言，底层数组的容量为 4。newSlice 无法访问位于其指针之前的底层数组元素。就 newSlice 而言，这些元素甚至并不存在。使用下面的方式可以为任意切片后的 newSlice 计算长度和容量。</p><h4 id="切片的长度与容量如何计算？"><a href="#切片的长度与容量如何计算？" class="headerlink" title="切片的长度与容量如何计算？"></a>切片的长度与容量如何计算？</h4><blockquote><p>切片 <strong>slice[i:j]</strong> 的<strong>底层数组容量为 k</strong><br>长度（Length）：j - i<br>容量（Capacity）：k - i</p></blockquote><p><strong>计算新的长度和容量</strong></p><blockquote><p>切片 <strong>slice[1:3]</strong> 的<strong>底层数组容量为 5</strong><br>长度（Length）：3 - 1 = 2<br>容量（Capacity）：5 - 1 = 4</p></blockquote><h4 id="对一个切片进行更改的结果"><a href="#对一个切片进行更改的结果" class="headerlink" title="对一个切片进行更改的结果"></a>对一个切片进行更改的结果</h4><p>一个切片对底层数组的共享部分所做的更改可以被另一个切片看到。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新的切片。</span></span><br><span class="line"><span class="comment">// 长度为 2，容量为 4。</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 变更新切片索引 1 位置的元素。</span></span><br><span class="line"><span class="comment">// 改变了原切片索引 2 位置的元素。</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">35</span></span><br></pre></td></tr></table></figure><p>将数值 35 分配给 newSlice 的第二个元素后，该更改也可以在原始切片的元素中被看到。</p><h4 id="运行时错误显示索引超出范围"><a href="#运行时错误显示索引超出范围" class="headerlink" title="运行时错误显示索引超出范围"></a>运行时错误显示索引超出范围</h4><p>一个切片只能访问它长度以内的索引位。尝试访问超出长度的索引位元素将引发一个运行时错误。与切片容量相关联的元素只能用于切片增长。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新的切片。</span></span><br><span class="line"><span class="comment">// 长度为 2，容量为 4。</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 变更 newSlice 索引 3 位置的元素。</span></span><br><span class="line"><span class="comment">// 对于 newSlice 而言，该元素不存在。</span></span><br><span class="line">newSlice[<span class="number">3</span>] = <span class="number">45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Runtime Exception:</span></span><br><span class="line"><span class="comment">panic: runtime error: index out of range</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h4><p>与使用数组相比，使用切片的优势之一是：你可以根据需要增加切片的容量。当你使用内置函数 「append」 时，Golang 会负责处理所有操作细节。</p><ul><li>使用 append 前，你需要一个源<strong>切片</strong>和一个要追加的值。</li><li>当你的 append 调用并返回时，它将为你提供一个更改后的新切片。 </li><li><strong>append</strong> 函数总会增加新切片的长度。</li><li>另一方面，容量可能会受到影响，也可能不会受到影响，这取决于源切片的可用容量。</li></ul><h4 id="使用-append-向切片追加元素"><a href="#使用-append-向切片追加元素" class="headerlink" title="使用 append 向切片追加元素"></a>使用 append 向切片追加元素</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度和容量均为 5。 */</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个新切片。</span></span><br><span class="line"><span class="comment"> 长度为 2，容量为 4。*/</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向容量空间分配新元素。</span></span><br><span class="line"><span class="comment"> 将值 60 分配给新元素。 */</span></span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 4</span></span><br></pre></td></tr></table></figure><p>当切片的底层数组没有可用容量时，append 函数将创建一个新的底层数组，拷贝正在引用的现有值，然后再分配新值。</p><h4 id="使用-append-增加切片的长度和容量"><a href="#使用-append-增加切片的长度和容量" class="headerlink" title="使用 append 增加切片的长度和容量"></a>使用 append 增加切片的长度和容量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印 4</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向切片追加新元素。</span></span><br><span class="line"><span class="comment">// 将值 50 分配给新元素。</span></span><br><span class="line">newSlice= <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 8</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn-images-1.medium.com/max/2000/1*GeiklLBspOlv_qxzw5GCVA.png" alt="图 9：增加切片的长度和容量"></p><p>在 append 操作后，newSlice 被给予一个自有的底层数组，该底层数组的容量是原底层数组容量的两倍。在增加底层数组容量时，append 操作十分聪明。举个例子，当切片的容量低于 1,000 个元素时，容量增长总是翻倍的。一旦元素的数量超过 1,000 个，容量就会增长 1.25 倍，即 25%。随着时间的推移，这种增长算法可能会在 Golang 中发生变化。</p><p>更改新切片不会对旧切片产生任何影响，因为新切片现在有一个不同的底层数组，它的指针指向一个新分配的数组。</p><h4 id="将一个切片追加到另一个切片中"><a href="#将一个切片追加到另一个切片中" class="headerlink" title="将一个切片追加到另一个切片中"></a>将一个切片追加到另一个切片中</h4><p>内置函数 <strong>append</strong> 还是一个 <strong>可变参数</strong> 函数。这意味着你可以传递多个值来追加到单个切片中。如果你使用 … 运算符，可以将一个切片的所有元素追加到另一个切片中。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个切片，使用两个整型元素初始化每个切片。</span></span><br><span class="line">slice1:= []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 合并两个切片并打印结果。</span></span><br><span class="line">fmt.Println(<span class="built_in">append</span>(slice1, slice2...))</span><br><span class="line"><span class="comment">// 输出：[1 2 3 4]</span></span><br></pre></td></tr></table></figure><h4 id="对切片执行索引"><a href="#对切片执行索引" class="headerlink" title="对切片执行索引"></a>对切片执行索引</h4><ul><li>通过指定一个下限和一个上限来形成切片，例如：<code>a[low:high]</code>。这将选择一个半开范围，其中包含切片的第一个元素，但不包含切片的最后一个元素。</li><li>你可以省略上限或下限，这将使用它们的默认值。下限的默认值是 0，上限的默认值是切片的长度。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"><span class="comment">// 一个数组</span></span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]               </span><br><span class="line"><span class="comment">// s == []int&#123;1, 2&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 3</span></span><br><span class="line">s = a[:<span class="number">2</span>]                 </span><br><span class="line"><span class="comment">// s == []int&#123;0, 1&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 4</span></span><br><span class="line">s = a[<span class="number">2</span>:]                 </span><br><span class="line"><span class="comment">// s == []int&#123;2, 3&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 2</span></span><br><span class="line">s = a[:]                  </span><br><span class="line"><span class="comment">// s == []int&#123;0, 1, 2, 3&#125;  </span></span><br><span class="line"><span class="comment">// cap(s) == 4</span></span><br></pre></td></tr></table></figure><h4 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h4><p>Go 有一个特殊的关键字 <strong>range</strong>，你可以使用该关键字对切片进行遍历。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 遍历每个元素并打印值。</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Index: 0 Value: 10</span></span><br><span class="line"><span class="comment">Index: 1 Value: 20</span></span><br><span class="line"><span class="comment">Index: 2 Value: 30</span></span><br><span class="line"><span class="comment">Index: 3 Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>在遍历切片时，关键字 range 将返回两个值。</li><li>第一个值是索引下标，第二个值是索引位中值的副本。</li><li>一定要知道 range 是在复制值，而不是返回值的引用。</li></ul><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度与容量均为 4。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 遍历每个元素并打印</span></span><br><span class="line"><span class="comment"> 元素的值和地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Value: %d Value-Addr: %X ElemAddr: %X\n"</span>,</span><br><span class="line">   value, &amp;value, &amp;slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100</span></span><br><span class="line"><span class="comment">Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104</span></span><br><span class="line"><span class="comment">Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108</span></span><br><span class="line"><span class="comment">Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>range</strong> 关键字提供元素的拷贝。</p><p>如果你不需要下标值，你可以使用下划线字符丢弃该值。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a slice of integers.</span></span><br><span class="line"><span class="comment">// Contains a length and capacity of 4 elements.</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// Iterate over each element and display each value.</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Value: %d\n"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Value: 10</span></span><br><span class="line"><span class="comment">Value: 20</span></span><br><span class="line"><span class="comment">Value: 30</span></span><br><span class="line"><span class="comment">Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关键字 <strong>range</strong> 总是从开始处遍历一个切片。如果你需要对切片的迭代进行更多的控制，你可以使用传统的 <strong>for</strong> 循环。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 从元素 30 开始遍历每个元素。</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++ &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Index: 2 Value: 30</span></span><br><span class="line"><span class="comment">Index: 3 Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，我们深入探讨了切片的概念。我们了解到，切片并不存储任何数据，而是描述了底层数组的一部分。我们还看到，切片可以在底层数组的范围内增长和收缩，并配合索引可作为数组使用；切片的零值是 nil；函数 <strong>len</strong>、<strong>cap</strong> 和 <strong>append</strong> 都将 <strong>nil</strong> 看作一个长度和容量都为 0 的<strong>空切片</strong>；你可以通过<strong>切片字面量</strong>或调用 <strong>make</strong> 函数（将长度和容量作为参数）来创建切片。希望这些对你有所帮助！</p><p><strong>免责声明</strong></p><p>我参考了各种博客、书籍和媒体故事来撰写这篇文章。如有任何疑问，请在评论中与我联系。</p><p><strong>到此为止……开心编码……快乐学习😃</strong></p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      这一数据结构为你提供了处理与管理数据集合的方法
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://jalan.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="翻译" scheme="http://jalan.space/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 覆盖索引与延迟关联</title>
    <link href="http://jalan.space/2020/09/01/2020/mysql-using-index/"/>
    <id>http://jalan.space/2020/09/01/2020/mysql-using-index/</id>
    <published>2020-09-01T12:35:00.000Z</published>
    <updated>2020-09-12T14:35:54.292Z</updated>
    
    <content type="html"><![CDATA[<p>在了解覆盖索引与延迟关联前，我们先简单建立一个订单表 Orders 用于举例说明。表中共包含 3 个字段：</p><ul><li><code>id</code>：订单 ID，<code>int</code> 类型，主键自增长</li><li><code>product_id</code>：商品 ID，在此列上建立索引</li><li><code>name</code>：订单名称</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`orders`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单 ID'</span>,</span><br><span class="line">  <span class="string">`product_id`</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品 ID'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'订单名称'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`product_idx`</span> (<span class="string">`product_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COLLATE</span>=utf8_unicode_ci;</span><br></pre></td></tr></table></figure><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p>我们知道，如果 MySQL <strong>根据索引</strong>查找到数据，但索引的叶子结点中并<strong>不包含</strong>我们所需要的数据字段，那么仍然需要进行回表查询。</p><p>如果一个索引包含（覆盖）我们所需要查询的所有字段值，我们就称之为「<strong>覆盖索引</strong>」。</p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>当使用  MyISAM 存储引擎时，由于我们在 <code>product_id</code> 建立了索引，所以 <code>SELECT product_id FROM orders</code> 将使用覆盖索引：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT product_id FROM orders;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key         | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | orders | NULL       | index | NULL          | product_idx | 5       | NULL |    2 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+-------------+---------+------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>如果我们在查询字段中加入 <code>id</code> 列，即执行 <code>SELECT id, product_id FROM orders WHERE product_id = 1</code>，查询轨迹如下：</p><ol><li>在 <code>product_id</code> 索引树中找到 <code>product_id = 1</code> 子结点</li><li>通过该子结点指针读取磁盘上的数据行</li><li>取出数据行中的 <code>id</code> 字段</li></ol><p>由于 MyISAM 的叶子结点存储着指向数据行的指针，该查询多了一步回表操作，无法使用覆盖索引。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT id, product_id FROM orders WHERE product_id = 1;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | orders | NULL       | ref  | product_idx   | product_idx | 5       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9bd49ad003d84c65b67395f7bbd1c592~tplv-k3u1fbpfcp-zoom-1.image" alt="MyISAM 索引结构"></p><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 与 MyISAM 的不同之处在于，InnoDB 的主键使用聚簇索引，而其<strong>二级索引的叶子结点保存着行的主键值</strong>。也就是说，二级索引不仅能覆盖其本身，也能覆盖到该行的主键值。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1e97a9099e1465ab51eed47171fb15d~tplv-k3u1fbpfcp-zoom-1.image" alt="InnoDB 二级索引的叶子结点包含行主键值"></p><p>由于 InnoDB 不同的数据存储方式，若使用 InnoDB 作为存储引擎，我们执行 <code>SELECT id, product_id FROM orders WHERE product_id = 1</code> 将得到如下结果：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT id, product_id FROM orders WHERE product_id = 1;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | orders | NULL       | ref  | product_idx   | product_idx | 5       | const |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>可以看到 <code>Extra</code> 显示 <code>Using index</code>，表示该查询使用了覆盖索引。该查询语句的查询轨迹如下：</p><ol><li>在二级索引 <code>product_id</code> 的索引树中找到 <code>product_id = 1</code> 的叶子结点</li><li>取出该叶子结点的行主键值 <code>id</code> 一并返回</li></ol><p>查询轨迹并未进行回表取值。</p><h3 id="覆盖索引的好处"><a href="#覆盖索引的好处" class="headerlink" title="覆盖索引的好处"></a>覆盖索引的好处</h3><h2 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h2><p>延迟关联（deferred join）指「延迟了对列的访问」，不直接获取所有需要的列。</p><p>在查询的第一阶段 MySQL 使用覆盖索引，再通过该覆盖索引查询到的结果到外层查询匹配锁需要的所有列值。</p><p>这样说有些抽象，我们来看看下面的例子。</p><h3 id="用延迟关联优化分页（LIMIT）"><a href="#用延迟关联优化分页（LIMIT）" class="headerlink" title="用延迟关联优化分页（LIMIT）"></a>用延迟关联优化分页（LIMIT）</h3><p>当使用 <code>LIMIT</code> 碰上较大偏移量时，例如 <code>LIMIT 10000, 20</code> 这样的查询，MySQL 需要查询 <code>10020</code> 条记录然后再返回最后的 20 条。前面的 10000 最终都会被抛弃，这样的代价非常高。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM orders LIMIT 10000, 20;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | orders | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    2 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br></pre></td></tr></table></figure><p>优化此类分页查询的一个最简单的办法就是<strong>尽可能使用索引覆盖扫描，而不是查询所有列</strong>。然后根据需要再做一次关联，返回所需要的列。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM orders AS o1 JOIN (SELECT id FROM orders LIMIT 10000, 20) AS o2 ON o1.id = o2.id;</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+-------------+---------+------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key         | key_len | ref        | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+-------------+---------+------------+------+----------+-------------+</span></span><br><span class="line">|  1 | PRIMARY     | o1         | NULL       | ALL   | PRIMARY       | NULL        | NULL    | NULL       |    2 |   100.00 | NULL        |</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 4       | test.o1.id |    2 |   100.00 | Using index |</span><br><span class="line">|  2 | DERIVED     | orders     | NULL       | index | NULL          | PRIMARY     | 4       | NULL       |    2 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+------------+------------+-------+---------------+-------------+---------+------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure><p>这样一来，MySQL 在 SQL 语句的「内层」进行扫描时使用了覆盖索引，「外层」再通过索引树找到相关的数据行，直接减少了扫描的数据量。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能 MySQL》</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何使用覆盖索引优化查询
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="MySQL" scheme="http://jalan.space/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis 中的 variable-precision SWAR 算法</title>
    <link href="http://jalan.space/2020/05/05/2020/variable-percision-swar/"/>
    <id>http://jalan.space/2020/05/05/2020/variable-percision-swar/</id>
    <published>2020-05-05T15:06:00.000Z</published>
    <updated>2020-05-06T13:42:17.811Z</updated>
    
    <content type="html"><![CDATA[<p>今天在看《Redis 设计与实现》中「二进制位数组」一章，书中讲述 <code>BITCOUNT</code> 命令时提及了「计算汉明重量（<em>Hamming Weight</em>）」，「汉明重量」是一串符号中<strong>非零符号</strong>的个数。</p><p>二进制位统计的常见算法有遍历算法、查表算法，在 <a href="https://leetcode-cn.com/problems/number-of-1-bits/" target="_blank" rel="noopener">LeetCode 191. 位1的个数</a> 一题中我也写过 <a href="https://leetcode-cn.com/problems/number-of-1-bits/solution/python-de-si-chong-xie-fa-by-jalan/" target="_blank" rel="noopener">相关题解</a>。Redis 在实现 <code>BITCOUNT</code> 命令时则使用了查表和 variable-precision SWAR 两种算法，本文将主要介绍 variable-precision SWAR 算法的实现原理。</p><h2 id="算法实现原理"><a href="#算法实现原理" class="headerlink" title="算法实现原理"></a>算法实现原理</h2><p>以计算 32 位二进制的汉明重量为例。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算 32 位二进制的汉明重量</span></span><br><span class="line"><span class="keyword">uint32_t</span> swar(<span class="keyword">uint32_t</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 步骤1</span></span><br><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2</span></span><br><span class="line">i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3</span></span><br><span class="line">i = (i &amp; <span class="number">0x0F0F0F0F</span>) + ((i &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤4</span></span><br><span class="line">i = (i * (<span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面拆分步骤进行分析。</p><h3 id="步骤一：-i-amp-0x55555555-i-gt-gt-1-amp-0x55555555"><a href="#步骤一：-i-amp-0x55555555-i-gt-gt-1-amp-0x55555555" class="headerlink" title="步骤一：(i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555)"></a>步骤一：(i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555)</h3><p><code>0x55555555</code> 的二进制表示为 <code>01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01</code>。</p><h4 id="i-amp-0x55555555"><a href="#i-amp-0x55555555" class="headerlink" title="i &amp; 0x55555555"></a>i &amp; 0x55555555</h4><p><code>i</code> 和 <code>0x55555555</code> 相与的结果偶数位全部置 0，奇数位与 <code>i</code> 保持一致。</p><h4 id="i-gt-gt-1"><a href="#i-gt-gt-1" class="headerlink" title="i &gt;&gt; 1"></a>i &gt;&gt; 1</h4><p>将 <code>i</code> 右移 1 位，丢弃最右边的奇数位，因此 <code>i</code> 中原奇数位变为偶数位，原偶数位变为奇数位。</p><h4 id="i-gt-gt-1-amp-0x55555555"><a href="#i-gt-gt-1-amp-0x55555555" class="headerlink" title="(i &gt;&gt; 1) &amp; 0x55555555"></a>(i &gt;&gt; 1) &amp; 0x55555555</h4><p>令 <code>i &gt;&gt; 1</code> 的结果为 <code>x</code>，则 <code>x &amp; 0x55555555</code> 的结果偶数位全部置 0，奇数位与 <code>x</code> 中奇数位保持一致。而 <code>x</code> 中的奇数位是 <code>i</code> 中的偶数位。</p><h4 id="i-amp-0x55555555-i-gt-gt-1-amp-0x55555555"><a href="#i-amp-0x55555555-i-gt-gt-1-amp-0x55555555" class="headerlink" title="(i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555)"></a>(i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555)</h4><p><code>(i &amp; 0x55555555) + ((i &gt;&gt; 1) &amp; 0x55555555)</code> 中，按每个二进制位为一组进行分组，各组的十进制表示就是该组的汉明重量。</p><hr><h3 id="步骤二：-i-amp-0x33333333-i-gt-gt-2-amp-0x33333333"><a href="#步骤二：-i-amp-0x33333333-i-gt-gt-2-amp-0x33333333" class="headerlink" title="步骤二：(i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)"></a>步骤二：(i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)</h3><p><code>0x33333333</code> 的二进制表示为 <code>0011 0011 0011 0011 0011 0011 0011 0011</code></p><h4 id="i-amp-0x33333333"><a href="#i-amp-0x33333333" class="headerlink" title="i &amp; 0x33333333"></a>i &amp; 0x33333333</h4><p><code>i</code> 中每 4 个二进制数为一组，每组中 2 个低位数字保持不变，高位数字置 0。</p><h4 id="i-gt-gt-2"><a href="#i-gt-gt-2" class="headerlink" title="i &gt;&gt; 2"></a>i &gt;&gt; 2</h4><p><code>i</code> 右移动 2 位，丢弃 2 个低位，因此原先一组中的 2 个高位变成低位，2 个低位被右移到右侧分组的高位中。</p><h4 id="i-gt-gt-2-amp-0x33333333"><a href="#i-gt-gt-2-amp-0x33333333" class="headerlink" title="(i &gt;&gt; 2) &amp; 0x33333333"></a>(i &gt;&gt; 2) &amp; 0x33333333</h4><p>令 <code>i &gt;&gt; 2</code> 结果为 <code>x</code>，<code>x</code> 依旧被分为 4 个一组，每组中 2 个高位置 0，2 个低位保持不变。</p><h4 id="i-amp-0x33333333-i-gt-gt-2-amp-0x33333333"><a href="#i-amp-0x33333333-i-gt-gt-2-amp-0x33333333" class="headerlink" title="(i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)"></a>(i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)</h4><p><code>(i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333)</code> 中每 4 个二进制数被分为一组，各组的十进制表示就是该组的汉明重量。</p><hr><h3 id="步骤三：-i-amp-0x0F0F0F0F-i-gt-gt-4-amp-0x0F0F0F0F"><a href="#步骤三：-i-amp-0x0F0F0F0F-i-gt-gt-4-amp-0x0F0F0F0F" class="headerlink" title="步骤三：(i &amp; 0x0F0F0F0F) + ((i &gt;&gt; 4) &amp; 0x0F0F0F0F);"></a>步骤三：(i &amp; 0x0F0F0F0F) + ((i &gt;&gt; 4) &amp; 0x0F0F0F0F);</h3><p><code>0x0F0F0F0F</code> 的二进制表示为 <code>00001111 00001111 00001111 00001111</code>。同上述步骤可知，步骤三 <code>(i &amp; 0x0F0F0F0F) + ((i &gt;&gt; 4) &amp; 0x0F0F0F0F)</code> 将步骤二的结果按每八个二进制位为一组进行分组，各组的十进制表示就是该组的明汉重量。</p><hr><h3 id="步骤四：-i-0x01010101-gt-gt-24"><a href="#步骤四：-i-0x01010101-gt-gt-24" class="headerlink" title="步骤四：(i * (0x01010101) &gt;&gt; 24)"></a>步骤四：(i * (0x01010101) &gt;&gt; 24)</h3><p><code>0x01010101</code> 的二进制表示为 <code>00000001 00000001 00000001 00000001</code>。</p><h4 id="i-0x01010101"><a href="#i-0x01010101" class="headerlink" title="i * (0x01010101)"></a>i * (0x01010101)</h4><p><code>i</code> 已经被分为八个二进制位为一组的分组，假设分组分别为 A、B、C、D（长度为 32 位，所以有 4 个分组），现在我们要求总结果，就要把这 4 个分组的值（即汉明重量）进行相加。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 分组 A</span><br><span class="line">i + </span><br><span class="line">// 分组 B 左移 8 位</span><br><span class="line">(i &lt;&lt; 8) + </span><br><span class="line">// 分组 C 左移 16 位</span><br><span class="line">(i &lt;&lt; 16) + </span><br><span class="line">// 分组 D 左移 24 位</span><br><span class="line">(i &lt;&lt; 24)</span><br><span class="line">= i * (1 + 1 &lt;&lt; 8 + 1 &lt;&lt; 16 + 1 &lt;&lt; 24) </span><br><span class="line">= i * 0x01010101</span><br></pre></td></tr></table></figure><p>因此，<code>i * (0x01010101)</code> 表示：将 <code>i</code> 的汉明重量聚集在二进制的最高八位。</p><h4 id="i-0x01010101-gt-gt-24"><a href="#i-0x01010101-gt-gt-24" class="headerlink" title="i * (0x01010101) &gt;&gt; 24"></a>i * (0x01010101) &gt;&gt; 24</h4><p>将最高八位右移成为最低八位，从而求出最终结果。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F" target="_blank" rel="noopener">汉明重量</a></li><li><a href="https://ivanzz1001.github.io/records/post/data-structure/2018/09/04/ds-variable-precision-SWAR" target="_blank" rel="noopener">variable precision SWAR算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何计算汉明重量？
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Redis" scheme="http://jalan.space/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>《Head First 设计模式》学习笔记 | 观察者模式</title>
    <link href="http://jalan.space/2020/03/30/2020/design-pattern-observer/"/>
    <id>http://jalan.space/2020/03/30/2020/design-pattern-observer/</id>
    <published>2020-03-30T14:40:00.000Z</published>
    <updated>2020-03-30T14:40:20.435Z</updated>
    
    <content type="html"><![CDATA[<p>往期回顾：</p><ul><li><a href="/2020/03/09/2020/design-pattern-strategy-pattern/">《Head First 设计模式》学习笔记 | 策略模式</a></li></ul><h2 id="设计气象观测站"><a href="#设计气象观测站" class="headerlink" title="设计气象观测站"></a>设计气象观测站</h2><p>以书中的气象监测应用为例：现在有一个气象中心可以监测温度、湿度、气压三种数据，我们需要通过 <code>WeatherData</code> 对象来获取这些数据，然后将这些数据显示在特定的装置上。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/29/1712533a92d605d0?w=978&amp;h=291&amp;f=png&amp;s=39407" alt=""></p><p><code>WeatherData</code> 拥有以下方法：</p><ul><li><code>getTemperature()</code>：获取温度数据</li><li><code>getHumidity()</code>： 获取湿度数据</li><li><code>getPressure()</code>：获取气压数据</li><li><code>measurementsChanged()</code>：一旦气象站更新数据，这个方法会被调用</li></ul><p>这样一看似乎十分简单：我们只要在 <code>measurementsChanged()</code> 中通过一系列 <code>getter</code> 获取到气象台提供的温度、湿度与气压数据，然后再调用显示装置的更新数据方法即可。</p><p>但是，如果我们后续需要增加或减少显示装置应该怎么办呢？每次都要修改 <code>measurementsChanged()</code> 显然不是个好办法。</p><h2 id="出版者与订阅者"><a href="#出版者与订阅者" class="headerlink" title="出版者与订阅者"></a>出版者与订阅者</h2><p>想想在现实生活中我们是怎么享受报纸订阅服务的？</p><ul><li>报社负责出版报纸，可以接受人们的订阅或取消订阅</li><li>如果我们向报社订阅了报纸，一旦有新报纸出版，报社就会送来新的报纸</li><li>如果我们不想看报纸了，就取消订阅，报社就不会再送新报纸上门</li></ul><p>气象站与显示装置之间其实也是这样的关系，气象站为「出版者」，显示装置为「订阅者」：<strong>需要获得气象站数据的显示装置可以向气象站申请「订阅」，这样一旦有气象数据更新，气象站就会通知申请订阅的显示装置；如果显示装置不再需要该气象站提供数据，则可以「取消订阅」，不再接受气象站的通知</strong>。</p><p>上述「出版者」称为「主题」（<em>Subject</em>），「订阅者」称为「观察者」（<em>Observer</em>），两者构成了观察者模式的主要部分。</p><h2 id="定义观察者模式"><a href="#定义观察者模式" class="headerlink" title="定义观察者模式"></a>定义观察者模式</h2><p>观察者模式定义如下：</p><blockquote><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/3/29/171257b0e5ae2438?w=673&amp;h=364&amp;f=png&amp;s=63287" alt="观察者模式类图"></p><p>类图中包含两个接口定义：</p><ul><li>主题接口 <code>Subject</code>：<ul><li><code>registerObserver()</code>：添加订阅者</li><li><code>removeObserver()</code>：移除订阅者</li><li><code>notifyObserver()</code>：通知订阅者</li></ul></li><li>观察者接口 <code>Observer</code>：<ul><li><code>update()</code>：在主题 <code>notifyObserver()</code> 中被调用，用于更新观察者的数据</li></ul></li></ul><h2 id="实现气象站"><a href="#实现气象站" class="headerlink" title="实现气象站"></a>实现气象站</h2><h3 id="设计类图"><a href="#设计类图" class="headerlink" title="设计类图"></a>设计类图</h3><p>根据上述观察者模式定义，我们先为气象站设计「主题」与「观察者」两个接口，除此之外也可以添加一个显示装置接口，专门负责显示装置的具体显示格式。</p><p>接口定义好后，就可以让具体的类来实现这些接口了：</p><ul><li><code>WeatherData</code> 作为具体主题，实现 <code>Subject</code> 主题接口</li><li>各个显示装置作为具体观察者，实现 <code>Observer</code> 观察者接口</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/3/29/1712587d2e56115e?w=911&amp;h=434&amp;f=png&amp;s=110929" alt="气象站类图"></p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主题接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerObserver</span><span class="params">($observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeObserver</span><span class="params">($observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($temp, $humidity, $pressure)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示装置显示接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * WeatherData 实现主题接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 观察者数组</span></span><br><span class="line">    <span class="keyword">private</span> $observers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> $temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> $humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> $pressure;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;observers = [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入新的观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerObserver</span><span class="params">($observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;observers[] = $observer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">removeObserver</span><span class="params">($observer)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $index = array_search($observer, <span class="keyword">$this</span>-&gt;observers);</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;observers[$index]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">notifyObservers</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历数组通知观察者</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;observers <span class="keyword">as</span> $observer) &#123;</span><br><span class="line">            $observer-&gt;update(<span class="keyword">$this</span>-&gt;temperature, <span class="keyword">$this</span>-&gt;humidity, <span class="keyword">$this</span>-&gt;pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">measurementsChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通知订阅者</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 气象站有新数据将调用该函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setMeasurements</span><span class="params">($temperature, $humidity, $pressure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;temperature = $temperature;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;humidity    = $humidity;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pressure    = $pressure;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建显示装置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示装置 1: 只显示温度和湿度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 温度</span></span><br><span class="line">    <span class="keyword">private</span> $temperature;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 湿度</span></span><br><span class="line">    <span class="keyword">private</span> $humidity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**<span class="doctag">@var</span> WeatherData $weatherData */</span></span><br><span class="line">    <span class="keyword">private</span> $weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($weatherData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 WeatherData 实例</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;weatherData = $weatherData;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;weatherData-&gt;registerObserver(<span class="keyword">$this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($temperature, $humidity, $pressure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;temperature = $temperature;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;humidity    = $humidity;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"当前温度：&#123;$this-&gt;temperature&#125;，当前湿度：&#123;$this-&gt;humidity&#125;\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示装置 2：只显示气压</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 气压</span></span><br><span class="line">    <span class="keyword">private</span> $pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**<span class="doctag">@var</span> WeatherData $weatherData */</span></span><br><span class="line">    <span class="keyword">private</span> $weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($weatherData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个 WeatherData 实例</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;weatherData = $weatherData;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;weatherData-&gt;registerObserver(<span class="keyword">$this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update</span><span class="params">($temperature, $humidity, $pressure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;pressure = $pressure;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"当前气压：&#123;$this-&gt;pressure&#125;\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 显示装置 3（略）</span></span><br><span class="line"><span class="comment"> * class ThirdDisplay</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试调用</span></span><br><span class="line"><span class="comment">// 创建一个 WeatherData 对象</span></span><br><span class="line">$weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line"><span class="comment">// 创建显示装置 1，传入 WeatherData 对象</span></span><br><span class="line">$firstDisplay = <span class="keyword">new</span> FirstDisplay($weatherData);</span><br><span class="line"><span class="comment">// 传入模拟气象数据</span></span><br><span class="line">$weatherData-&gt;setMeasurements(<span class="number">80</span>, <span class="number">70</span>, <span class="number">30.4</span>);</span><br><span class="line">$weatherData-&gt;setMeasurements(<span class="number">70</span>, <span class="number">60</span>, <span class="number">29.2</span>);</span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line">$weatherData-&gt;removeObserver($firstDisplay);</span><br><span class="line"><span class="comment">// 创建显示装置 2，传入 WeatherData 对象</span></span><br><span class="line">$secondDisplay = <span class="keyword">new</span> SecondDisplay($weatherData);</span><br><span class="line">$weatherData-&gt;setMeasurements(<span class="number">90</span>, <span class="number">60</span>, <span class="number">29.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">当前温度：80，当前湿度：70</span></span><br><span class="line"><span class="comment">当前温度：70，当前湿度：60</span></span><br><span class="line"><span class="comment">当前气压：29.2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        主题（出版者）</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._observers = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        添加观察者</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> observer <span class="keyword">not</span> <span class="keyword">in</span> self._observers:</span><br><span class="line">            self._observers.append(observer)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, observer)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        移除观察者</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self._observers.remove(observer)</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        发送通知给所有观察者</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> observer <span class="keyword">in</span> self._observers:</span><br><span class="line">            observer.update()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span><span class="params">(Subject)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        Subject.__init__(self)</span><br><span class="line">        self._temperature = <span class="number">0</span> <span class="comment"># 温度</span></span><br><span class="line">        self._humidity = <span class="number">0</span> <span class="comment"># 湿度</span></span><br><span class="line">        self._pressure = <span class="number">0</span> <span class="comment"># 气压</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_measurements</span><span class="params">(self, temperature, humidity, pressure)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        气象数据发生变动时调用该函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._temperature = temperature</span><br><span class="line">        self._humidity = humidity</span><br><span class="line">        self._pressure = pressure</span><br><span class="line">        self.notify()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">temperature</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._temperature</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">humidity</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._humidity</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pressure</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._pressure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstDisplay</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weatherData)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        显示装置 1：显示温度和湿度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._weather_data = weatherData</span><br><span class="line">        self._weather_data.register(self)</span><br><span class="line">        self._temperature = <span class="number">0</span></span><br><span class="line">        self._humidity = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        更新数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._temperature = self._weather_data.temperature</span><br><span class="line">        self._humidity = self._weather_data.humidity</span><br><span class="line">        self.display()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        显示数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        print(<span class="string">"当前温度：%s，当前湿度：%s"</span> % (self._temperature, self._humidity))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondDisplay</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weatherData)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        显示装置 2：显示气压</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._weather_data = weatherData</span><br><span class="line">        self._weather_data.register(self)</span><br><span class="line">        self._pressure = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        更新数据</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._pressure = self._weather_data.pressure</span><br><span class="line">        self.display()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"当前气压：%s"</span> % self._pressure)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个 WeatherData 对象</span></span><br><span class="line">    weather_data = WeatherData()</span><br><span class="line">    <span class="comment"># 创建显示装置 1</span></span><br><span class="line">    first_display = FirstDisplay(weather_data)</span><br><span class="line">    <span class="comment"># 传入模拟数据</span></span><br><span class="line">    weather_data.set_measurements(<span class="number">21</span>, <span class="number">50</span>, <span class="number">3</span>)</span><br><span class="line">    weather_data.set_measurements(<span class="number">3</span>, <span class="number">70</span>, <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 移除</span></span><br><span class="line">    weather_data.remove(first_display)</span><br><span class="line">    <span class="comment"># 添加装置 2</span></span><br><span class="line">    second_display = SecondDisplay(weather_data)</span><br><span class="line">    weather_data.set_measurements(<span class="number">21</span>, <span class="number">50</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Output:</span></span><br><span class="line"><span class="string">当前温度：21，当前湿度：50</span></span><br><span class="line"><span class="string">当前温度：3，当前湿度：70</span></span><br><span class="line"><span class="string">当前气压：30</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h4 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subject 主题</span></span><br><span class="line"><span class="keyword">type</span> Subject <span class="keyword">interface</span> &#123;</span><br><span class="line">Register(observer Observer)</span><br><span class="line">Remove(obeserver Observer)</span><br><span class="line">Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// WeatherData 具体主题</span></span><br><span class="line"><span class="keyword">type</span> WeatherData <span class="keyword">struct</span> &#123;</span><br><span class="line">observers   []Observer</span><br><span class="line">temperature <span class="keyword">int</span></span><br><span class="line">humidity    <span class="keyword">int</span></span><br><span class="line">pressure    <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeatherData)</span> <span class="title">Register</span><span class="params">(observer Observer)</span></span> &#123;</span><br><span class="line">w.observers = <span class="built_in">append</span>(w.observers, observer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消订阅</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeatherData)</span> <span class="title">Remove</span><span class="params">(observer Observer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 双指针法：找到需要取消订阅的对象并覆盖</span></span><br><span class="line">j := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, ob := <span class="keyword">range</span> w.observers &#123;</span><br><span class="line"><span class="keyword">if</span> ob != observer &#123;</span><br><span class="line">w.observers[j] = observer</span><br><span class="line">j++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w.observers = w.observers[:j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知所有订阅者</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeatherData)</span> <span class="title">Notify</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> _, observer := <span class="keyword">range</span> w.observers &#123;</span><br><span class="line">observer.update(w.temperature, w.humidity, w.pressure)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置新的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WeatherData)</span> <span class="title">SetMeasurements</span><span class="params">(temperature <span class="keyword">int</span>, humidity <span class="keyword">int</span>, pressure <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">w.temperature = temperature</span><br><span class="line">w.humidity = humidity</span><br><span class="line">w.pressure = pressure</span><br><span class="line">w.Notify()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Observer 观察者</span></span><br><span class="line"><span class="keyword">type</span> Observer <span class="keyword">interface</span> &#123;</span><br><span class="line">update(temperature <span class="keyword">int</span>, humidity <span class="keyword">int</span>, pressure <span class="keyword">float32</span>)</span><br><span class="line">display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FirstDisplay 显示装置 1</span></span><br><span class="line"><span class="keyword">type</span> FirstDisplay <span class="keyword">struct</span> &#123;</span><br><span class="line">temperature <span class="keyword">int</span></span><br><span class="line">humidity    <span class="keyword">int</span></span><br><span class="line">pressure    <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(display *FirstDisplay)</span> <span class="title">update</span><span class="params">(temperature <span class="keyword">int</span>, humidity <span class="keyword">int</span>, pressure <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">display.temperature = temperature</span><br><span class="line">display.humidity = humidity</span><br><span class="line">display.pressure = pressure</span><br><span class="line">display.display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(display *FirstDisplay)</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"当前温度：%d， 当前湿度：%d\n"</span>, display.temperature, display.humidity)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SecondDisplay 显示装置 2</span></span><br><span class="line"><span class="keyword">type</span> SecondDisplay <span class="keyword">struct</span> &#123;</span><br><span class="line">temperature <span class="keyword">int</span></span><br><span class="line">humidity    <span class="keyword">int</span></span><br><span class="line">pressure    <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(display *SecondDisplay)</span> <span class="title">update</span><span class="params">(temperature <span class="keyword">int</span>, humidity <span class="keyword">int</span>, pressure <span class="keyword">float32</span>)</span></span> &#123;</span><br><span class="line">display.temperature = temperature</span><br><span class="line">display.humidity = humidity</span><br><span class="line">display.pressure = pressure</span><br><span class="line">display.display()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(display *SecondDisplay)</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"当前气压：%.2f\n"</span>, display.pressure)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">weatherData := WeatherData&#123;&#125;</span><br><span class="line"><span class="comment">// 创建显示装置 1</span></span><br><span class="line">firstDisplay := &amp;FirstDisplay&#123;&#125;</span><br><span class="line">weatherData.Register(firstDisplay)</span><br><span class="line">weatherData.SetMeasurements(<span class="number">23</span>, <span class="number">50</span>, <span class="number">23.1</span>)</span><br><span class="line"><span class="comment">// weatherData.Remove(firstDisplay)</span></span><br><span class="line"><span class="comment">// 创建显示装置 2</span></span><br><span class="line">secondDisplay := &amp;SecondDisplay&#123;&#125;</span><br><span class="line">weatherData.Register(secondDisplay)</span><br><span class="line">weatherData.SetMeasurements(<span class="number">22</span>, <span class="number">70</span>, <span class="number">24.2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>观察者模式定义了对象之间一对多的关系</li><li>主题通过一个共同的接口来更新观察者</li><li>主题和观察者之间用松耦合方式结合，主题不需要知道观察者的细节，具体观察者只需要实现观察者的接口</li></ul>]]></content>
    
    <summary type="html">
    
      松耦合的魅力
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://jalan.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【译】用依赖注入解耦你的代码</title>
    <link href="http://jalan.space/2020/03/29/2020/decouple-your-code-with-dependency-injection/"/>
    <id>http://jalan.space/2020/03/29/2020/decouple-your-code-with-dependency-injection/</id>
    <published>2020-03-29T12:37:00.000Z</published>
    <updated>2021-01-19T11:33:31.910Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用依赖注入解耦你的代码"><a href="#用依赖注入解耦你的代码" class="headerlink" title="用依赖注入解耦你的代码"></a>用依赖注入解耦你的代码</h1><blockquote><p>无需第三方框架</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/3/29/1712677f078f2350?w=4000&amp;h=2670&amp;f=jpeg&amp;s=985847" alt="[Icons8 团队](https://unsplash.com/@icons8?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText) 摄于 [Unsplash](https://unsplash.com/s/photos/ingredients?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText)"></p><p>没有多少组件是能够独立存在而不依赖于其它组件的。除了创建紧密耦合的组件，我们还可以利用<strong>依赖注入</strong>（DI）来改善 <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">关注点的分离</a>。</p><p>这篇文章将会脱离第三方框架向你介绍依赖注入的核心概念。所有的示例代码都将使用 Java，但所介绍的一般原则也适用于其它任何语言。</p><hr><h2 id="示例：数据处理器"><a href="#示例：数据处理器" class="headerlink" title="示例：数据处理器"></a>示例：数据处理器</h2><p>为了让如何使用依赖注入更加形象化，我们将从一个简单的类型开始：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DbManager manager = <span class="keyword">new</span> SqliteDbManager(<span class="string">"db.sqlite"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Calculator calculator = <span class="keyword">new</span> HighPrecisionCalculator(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager.processData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calc</span><span class="params">(BigDecimal input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calculator.expensiveCalculation(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DataProcessor</code> 有两个依赖项：<code>DbManager</code> 和 <code>Calculator</code>。直接在我们的类型中创建它们有几个明显的缺点：</p><ul><li>调用构造函数时可能发生崩溃</li><li>构造函数签名可能会改变</li><li>紧密绑定到显式实现类型</li></ul><p>是时候改进它了！</p><hr><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p><a href="https://www.amazon.com/Art-Agile-Development-Pragmatic-Software/dp/0596527675" target="_blank" rel="noopener"><strong>《敏捷开发的艺术》</strong></a> 的作者 James Shore <a href="https://www.jamesshore.com/Blog/Dependency-Injection-Demystified.html" target="_blank" rel="noopener">很好地指出</a>：</p><blockquote><p><strong>「依赖注入听起来复杂，实际上它的概念却十分简单。」</strong></p></blockquote><p>依赖注入的概念实际上非常简单：为组件提供完成其工作所需的一切。</p><p>通常，这意味着通过从外部提供组件的依赖关系来解耦组件，而非直接在组件内创建依赖，让组件间过度耦合。</p><p>我们可以通过多种方式为实例提供必要的依赖关系：</p><ul><li>构造函数注入</li><li>属性注入</li><li>方法注入</li></ul><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>构造函数注入，或称基于初始化器的依赖注入，意味着在实例初始化期间提供所有必需的依赖项，将其作为构造函数的参数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DbManager manager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataProcessor</span><span class="params">(DbManager manager, Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.manager = manager;</span><br><span class="line">        <span class="keyword">this</span>.calculator = calculator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这一简单的改变，我们可以弥补大多数最开始的缺点：</p><ul><li>易于替换：<code>DbManager</code> 和 <code>Calculator</code> 不再被具体的实现所束缚，现在可以模拟单元测试了。</li><li>已经初始化并且「准备就绪」：我们不必担心依赖项所需要的任何子依赖项（例如，数据库文件名、<a href="https://zh.wikipedia.org/wiki/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97" target="_blank" rel="noopener">有效数字（译者注）</a>等），也不必担心它们可在初始化期间发生崩溃的可能性。</li><li>强制要求：调用方确切地知道创建 <code>DataProcessor</code> 的所需内容。</li><li>不变性：依赖关系始终如初。</li></ul><p>尽管构造函数注入是许多依赖注入框架的首选方法，但它也有明显的缺点。其中最大的缺点是：必须在初始化时提供所有依赖项。</p><p>有时，我们无法自己初始化一个组件，或者在某个时刻我们无法提供组件的所有依赖关系。或者我们需要使用另外一个构造函数。一旦设置了依赖项，我们就无法再改变它们了。</p><p>但是我们可以使用其它注入类型来缓解这些问题。</p><h4 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h4><p>有时，我们无法访问类型实际的初始化方法，只能访问一个已经初始化的实例。或者在初始化时，所需要的依赖关系并不像之后那样明确。</p><p>在这些情况下，我们可以使用<strong>属性注入</strong>而不是依赖于构造函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> DbManager manager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> Calculator calculator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// WARNING: Possible NPE</span></span><br><span class="line">        <span class="keyword">this</span>.manager.processData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calc</span><span class="params">(BigDecimal input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// WARNING: Possible NPE</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.calculator.expensiveCalculation(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们不再需要构造函数了，在初始化后我们可以随时提供依赖项。但这种注入方式也有缺点：<strong>易变性</strong>。</p><p>在初始化后，我们不再保证 <code>DataProcessor</code> 是「随时可用」的。能够随意更改依赖关系可能会给我们带来更大的灵活性，但同时也会带来运行时检查过多的缺点。</p><p>现在，我们必须在访问依赖项时处理出现 <code>NullPointerException</code> 的可能性。</p><h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><p>即使我们将依赖项与构造函数注入与/或属性注入分离，我们也仍然只有一个选择。如果在某些情况下我们需要另一个 <code>Calculator</code> 该怎么办呢？</p><p>我们不想为第二个 <code>Calculator</code> 类添加额外的属性或构造函数参数，因为将来可能会出现第三个这样的类。而且在每次调用 <code>calc(...)</code> 前更改属性也不可行，并且很可能因为使用错误的属性而导致 bug。</p><p>更好的方法是参数化调用方法本身及其依赖项：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calc</span><span class="params">(Calculator calculator, BigDecimal input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> calculator.expensiveCalculation(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>calc(...)</code> 的调用者负责提供一个合适的 <code>Calculator</code> 实例，并且 <code>DataProcessor</code> 类与之完全分离。</p><p>通过混合使用不同的注入类型来提供一个默认的 <code>Calculator</code>，这样可以获得更大的灵活性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Calculator defaultCalculator;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataProcessor</span><span class="params">(Calculator calculator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultCalculator = calculator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">calc</span><span class="params">(Calculator calculator, BigDecimal input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(calculator)</span><br><span class="line">                       .orElse(<span class="keyword">this</span>.calculator)</span><br><span class="line">                       .expensiveCalculation(input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用者<strong>可以</strong>提供另一种类型的 <code>Calculator</code>，但这不是<strong>必须</strong>的。我们仍然有一个解耦的、随时可用的 <code>DataProcessor</code>，它能够适应特定的场景。</p><h2 id="选择哪种注入方式？"><a href="#选择哪种注入方式？" class="headerlink" title="选择哪种注入方式？"></a>选择哪种注入方式？</h2><p>每种依赖注入类型都有自己的优点，并没有一种「正确的方法」。具体的选择完全取决于你的实际需求和情况。</p><h4 id="构造函数注入-1"><a href="#构造函数注入-1" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><p>构造函数注入是我的最爱，它也常受依赖注入框架的青睐。</p><p>它清楚地告诉我们创建特定组件所需的所有依赖关系，并且这些依赖不是可选的，这些依赖关系在整个组件中应该都是必需的。</p><h4 id="属性注入-1"><a href="#属性注入-1" class="headerlink" title="属性注入"></a>属性注入</h4><p>属性注入更适合可选参数，例如监听或委托。又或是我们无法在初始化时提供依赖关系。</p><p>其它编程语言，例如 Swift，大量使用了带属性的 <a href="https://en.wikipedia.org/wiki/Delegation_pattern" target="_blank" rel="noopener">委托模式</a>。因此，使用属性注入将使其它语言的开发人员更熟悉我们的代码。</p><h4 id="方法注入-1"><a href="#方法注入-1" class="headerlink" title="方法注入"></a>方法注入</h4><p>如果在每次调用时依赖项可能不同，那么使用方法注入最好不过了。方法注入进一步解耦组件，它使方法本身持有依赖项，而非整个组件。</p><p>请记住，这不是非此即彼。我们可以根据需要自由组合各种注入类型。</p><h2 id="控制反转容器"><a href="#控制反转容器" class="headerlink" title="控制反转容器"></a>控制反转容器</h2><p>这些简单的依赖注入实现可以覆盖很多用例。依赖注入是很好的解耦工具，但事实上我们仍然需要在某些时候创建依赖项。</p><p>但随着应用程序和代码库的增长，我们可能还需要一个更完整的解决方案来简化依赖注入的创建和组装过程。</p><p><strong>控制反转</strong>（IoC）是 <a href="https://en.wikipedia.org/wiki/Control_flow" target="_blank" rel="noopener">控制流</a> 的抽象原理。依赖注入是控制反转的具体实现之一。</p><p><strong>控制反转容器</strong>是一种特殊类型的对象，它知道如何实例化和配置其它对象，它也知道如何帮助你执行依赖注入。</p><p>有些容器可以通过反射来检测关系，而另一些必须手动配置。有些容器基于运行时，而有些则在编译时生成所需要的所有代码。</p><p>比较所有容器的不同之处超出了本文的讨论范围，但是让我通过一个小示例来更好地理解这个概念。</p><h4 id="示例-Dagger-2"><a href="#示例-Dagger-2" class="headerlink" title="示例: Dagger 2"></a>示例: Dagger 2</h4><p><a href="https://dagger.dev/" target="_blank" rel="noopener">Dagger</a> 是一个轻量级、编译时进行依赖注入的框架。我们需要创建一个 <code>Module</code>，它就知道如何构建我们的依赖项，稍后我们只要添加 <code>@Inject</code> 注释就可以注入这个 <code>Module</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Module</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectionModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> DbManager <span class="title">provideManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Calculator <span class="title">provideCalculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HighPrecisionCalculator(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@Singleton</code> 确保只能创建一个依赖项的实例。</p><p>要注入依赖项，我们只需要将 <code>@Inject</code> 添加到构造函数、字段或方法中。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    DbManager manager;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些仅仅是一些基础知识，乍一看不可能会给人留下深刻的印象。但是控制反转容器和框架不仅解耦了组件，也让创建依赖关系的灵活性得以最大化。</p><p>由于提供了高级特性，创建过程的可配置性变得更强，并且支持了使用依赖项的新方法。</p><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><p>这些特性在不同类型的控制反转容器和底层语言之间差异很大，比如：</p><ul><li><a href="https://en.wikipedia.org/wiki/Proxy_pattern" target="_blank" rel="noopener">代理模式</a> 和延迟加载。</li><li>生命周期（例如：单例模式与每个线程一个实例）。</li><li>自动绑定。</li><li>单一类型的多种实现。</li><li>循环依赖。</li></ul><p>这些特性是控制反转容器真正的能力。你可能会认为诸如「循环依赖」这样的特性并非好的主意，确实如此。</p><p>但是，如果由于遗留代码或是过去不可更改的错误设计而需要这种奇怪的代码构造，那么我们现在有能力可以这样做。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们应该根据抽象（例如接口）而不是具体的实现来设计代码，这样可以帮助我们减少代码耦合。</p><p>接口必须提供我们代码所需要的唯一信息，我们不能对实际实现情况做任何假设。</p><blockquote><p><strong>「程序应当依赖抽象，而非具体的实现」</strong><br>—— Robert C. Martin (2000), 《设计原则与设计模式》</p></blockquote><p>依赖注入是通过解耦组件来实现这一点的好办法。它使我们能够编写更简洁明了、更易于维护和重构的代码。</p><p>选择三种依赖注入类型中的哪种很大程度上取决于环境和需求，但是我们也可以混合使用三种类型使收益最大化。</p><p>控制反转容器有时几乎以一种神奇的方式通过简化组件创建过程来提供另一种便利的布局。</p><p>我们应该处处使用它吗？当然不是。</p><p>就像其它模式和概念一样，我们应该在适当的时候应用它们，而不是能用则用。</p><p>永远不要把自己局限在一种做事的方式上。也许 <a href="https://en.wikipedia.org/wiki/Factory_method_pattern" target="_blank" rel="noopener">工厂模式</a> 甚至是广为厌恶的 <a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">单例模式</a> 是能够满足你需求的更好的解决方案。</p><hr><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://www.martinfowler.com/articles/injection.html" target="_blank" rel="noopener">控制反转容器与依赖注入模式</a> (Martin Fowler)</li><li><a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">依赖反转原则</a>（维基百科）</li><li><a href="https://en.wikipedia.org/wiki/Inversion_of_control" target="_blank" rel="noopener">控制反转</a>（维基百科）</li></ul><hr><h2 id="控制反转容器-1"><a href="#控制反转容器-1" class="headerlink" title="控制反转容器"></a>控制反转容器</h2><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul><li><a href="https://dagger.dev/" target="_blank" rel="noopener">Dagger</a></li><li><a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-introduction" target="_blank" rel="noopener">Spring</a></li><li><a href="https://tapestry.apache.org/ioc.html" target="_blank" rel="noopener">Tapestry</a></li></ul><h4 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h4><ul><li><a href="https://insert-koin.io/" target="_blank" rel="noopener">Koin</a></li></ul><h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><ul><li><a href="https://github.com/AliSoftware/Dip" target="_blank" rel="noopener">Dip</a></li><li><a href="https://github.com/Swinject/Swinject" target="_blank" rel="noopener">Swinject</a></li></ul><h4 id="C"><a href="#C" class="headerlink" title="C"></a>C</h4><ul><li><a href="https://autofac.org/" target="_blank" rel="noopener">Autofac</a></li><li><a href="http://www.castleproject.org/projects/windsor/" target="_blank" rel="noopener">Castle Windsor</a></li></ul><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      没有多少组件是能够独立存在而不依赖于其它组件的。除了创建紧密耦合的组件，我们还可以利用依赖注入（DI）来改善关注点的分离
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://jalan.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="翻译" scheme="http://jalan.space/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>《Head First 设计模式》学习笔记 | 策略模式</title>
    <link href="http://jalan.space/2020/03/09/2020/design-pattern-strategy-pattern/"/>
    <id>http://jalan.space/2020/03/09/2020/design-pattern-strategy-pattern/</id>
    <published>2020-03-09T14:15:00.000Z</published>
    <updated>2020-03-09T14:16:33.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我最近在看大名鼎鼎的《Head First 设计模式》。这本「OO 圣经」用 Java 实现各类设计模式，对于我 —— 一个非 Java 爱好者而言，读起来并不过瘾。</p><p>有人读完这本书可能会误解设计模式就是设计 Interface，而事实并非如此。在知乎的一个问题<a href="https://www.zhihu.com/question/20685467" target="_blank" rel="noopener">《Python 里没有接口，如何写设计模式？》</a>中，<a href="https://www.zhihu.com/people/excited-vczh/activities" target="_blank" rel="noopener">vczh</a> 轮子哥是这样回答的：</p><blockquote><p>设计模式搞了那么多东西就是在告诉你<strong>如何在各种情况下解耦你的代码，让你的代码在运行时可以互相组合</strong>。这就跟兵法一样。难道有了飞机大炮，兵法就没有用了吗？</p></blockquote><p>我觉得这个比喻很好，不同的语言就像不同的兵器，各有各的特点与使用方式，而设计模式就是那套「兵法」，无论你使用何种兵器，不过是「纵横不出方圆，万变不离其宗」。而只看书中一种「兵器」未免太少，不如我们多试几样？</p><p>本篇就来看一看第一章「兵法」 —— 策略模式（<em>Strategy Pattern</em>）。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>书中对策略模式的定义如下：</p><blockquote><p>策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p></blockquote><p>下面以书中的「模拟鸭子应用」为例。</p><h2 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h2><p>你要设计一个鸭子游戏，游戏里有各种各样的鸭子，它们会游泳（<code>swim()</code>），还会呱呱叫（<code>quack()</code>），每种鸭子拥有不同的外观（<code>display()</code>）。</p><p>一开始，你可能会设计一个鸭子的超类 <code>Duck</code>，然后让所有不同种类的鸭子继承它：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f93ce4aecf95a9?w=928&amp;h=575&amp;f=png&amp;s=44162" alt="设计一个鸭子超类（Superclass）"></p><p>如果此时我们想让鸭子飞起来，就要在超类中增加一个 <code>fly()</code> 方法：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f93d4fe2ad11e4?w=928&amp;h=575&amp;f=png&amp;s=51352" alt="让鸭子飞"></p><p>此时，鸭子家族来了一只擅于代码调试工作的小黄鸭。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f93d78bf4775e3?w=720&amp;h=480&amp;f=jpeg&amp;s=4512" alt=""></p><p>此时，一切都乱套了，这位代码调试工作者会发出「吱吱」的叫声，但却不会飞，然而它却从鸭子超类继承了 <code>quack()</code> 和 <code>fly()</code> 方法。为了让它尊重客观事实，我们需要在小黄鸭类中覆盖超类的 <code>quack()</code> 和 <code>fly()</code> 方法，让它变得不会叫也不会飞。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f93e06edacc785?w=897&amp;h=660&amp;f=png&amp;s=69744" alt="在小黄鸭中覆盖原有的方法"></p><p>虽然我们用「覆盖方法」的手段解决了小黄鸭的问题，但未来我们可能还会制造更多奇奇怪怪的鸭子。例如周黑鸭或北京烤鸭，它们显然既不会叫，也不会游泳，还不会飞，这时我们又要为它们重写所有的行为吗？利用继承的方式来为不同种类的鸭子提供行为显然不够灵活。</p><h2 id="抽离可变行为"><a href="#抽离可变行为" class="headerlink" title="抽离可变行为"></a>抽离可变行为</h2><p>不同的鸭子具有不同的行为，<strong>鸭子的行为应当是灵活可变的</strong>。</p><blockquote><p><strong>设计原则一</strong>：找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</p></blockquote><p>因此，利用上述原则，我们把「鸭子的行为」从鸭子类（<em>Duck</em>）中抽离出来。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f94127e9058e99?w=727&amp;h=480&amp;f=png&amp;s=43051" alt="取出容易变化的行为"></p><h2 id="实现被抽离的行为"><a href="#实现被抽离的行为" class="headerlink" title="实现被抽离的行为"></a>实现被抽离的行为</h2><blockquote><p><strong>设计原则二</strong>：针对接口编程，而不是针对实现编程。</p></blockquote><p>我们将这些被抽离出的行为归类：</p><ul><li>所有具体的飞行行为属于飞行策略</li><li>所有具体的叫声行为属于叫声策略</li><li>所有具体的游泳行为属于游泳策略</li><li>……</li></ul><p>我们可以利用接口或抽象类代表这些<strong>策略</strong>，然后<strong>让特定的具体行为来实现这些策略中的方法</strong>。</p><p>例如，我们的飞行策略名为 <code>FlyBehavior</code>，我们将它设计为一个抽象类（当然也可以是接口）。然后，我们有两种具体的飞行方式 <code>FlyWithWings</code>（会飞）和 <code>FlyNoWay</code>（不会飞），它们需要实现飞行策略中的 <code>fly()</code> 方法：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f943b6cc1ece6c?w=640&amp;h=407&amp;f=png&amp;s=22118" alt=""></p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>此时，我们已经将可变的行为从鸭子超类（<code>Duck</code>）中抽离，并把它们用具体的「行为类」进行表示。我们希望：<strong>如果鸭子要执行某个行为，它不需要自己处理，而是将这一行为委托给具体的「行为类」</strong>。</p><p>因此，我们可以在鸭子超类（<code>Duck</code>）中加入「行为类」的实例变量，从而通过这些实例变量来调用具体的行为方法。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f9446b3dde8d5b?w=707&amp;h=294&amp;f=png&amp;s=22524" alt=""></p><p>在 <code>Class Duck</code> 的 <code>fly()</code> 方法中，我们可以使用实例 <code>flyBehavior</code> 调用具体的行为方法，从而达成「委托」的目的：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;flyBehavior-&gt;fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面来看看不同语言的具体实现：</p><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p>PHP 有抽象类也有接口，语法和 Java 比较接近。实现方法中规中矩，和书中的并无二致。只不过这里我把行为接口改成了抽象类。类图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/11/16f9495446251c43?w=1628&amp;h=758&amp;f=png&amp;s=103391" alt="UML 类图关系"></p><p>具体实现：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 飞行行为类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyBehavior</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「飞」的具体行为</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyWithWings</span> <span class="keyword">extends</span> <span class="title">FlyBehavior</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"会飞\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyNoWay</span> <span class="keyword">extends</span> <span class="title">FlyBehavior</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"不会飞\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 叫声行为类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">QuackBehavior</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「叫」的具体行为</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quack</span> <span class="keyword">extends</span> <span class="title">QuackBehavior</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"呱呱\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Squeak</span> <span class="keyword">extends</span> <span class="title">QuackBehavior</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"吱吱\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MuteQuack</span> <span class="keyword">extends</span> <span class="title">QuackBehavior</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"不会叫\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鸭子类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $flyStrategy;</span><br><span class="line">    <span class="keyword">protected</span> $quackStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">fly</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;flyStrategy-&gt;fly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">quack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;quackStrategy-&gt;quack();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有只小黄鸭</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YellowDuck</span> <span class="keyword">extends</span> <span class="title">Duck</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($flyStrategy, $quackStrategy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;flyStrategy = $flyStrategy;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;quackStrategy = $quackStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$yellowDuck = <span class="keyword">new</span> YellowDuck(<span class="keyword">new</span> FlyNoWay(), <span class="keyword">new</span> Squeak());</span><br><span class="line">$yellowDuck-&gt;fly();</span><br><span class="line">$yellowDuck-&gt;quack();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">不会飞</span></span><br><span class="line"><span class="comment">吱吱</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>Python 就没有所谓的抽象类和接口了，当然你也可以通过 <code>abc</code> 模块来实现这些功能。</p><p>比较简单的做法是：将具体行为直接定义为函数，在初始化鸭子时通过构造函数传入行为函数，赋值给对应的变量。当执行具体行为时，将直接调用被赋值的变量，这时具体的行为动作就被委托给了传入的行为函数，达到了「委托」的效果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fly_strategy, quack_strategy)</span>:</span></span><br><span class="line">        self.fly_strategy = fly_strategy</span><br><span class="line">        self.quack_strategy = quack_strategy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fly</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fly_strategy()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.quack_strategy()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_with_wings</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"会飞"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fly_no_way</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"不会飞"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"呱呱"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squeak</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"吱吱"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mute_quack</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"不会叫"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一只会飞也不会叫的小黄鸭</span></span><br><span class="line">yellow_duck = Duck(fly_no_way, mute_quack)</span><br><span class="line">yellow_duck.fly()</span><br><span class="line">yellow_duck.quack()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 不会飞</span></span><br><span class="line"><span class="comment"># 不会叫</span></span><br></pre></td></tr></table></figure><h3 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h3><p>在 Go 语言中没有 <code>extends</code> 关键字，但可以通过<strong>在结构体中内嵌匿名类型</strong>的方式实现继承关系。此处，将 <code>FlyBehavior</code> 飞行行为和 <code>QuackBehavior</code> 行为声明为接口。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyBehavior 飞行行为接口</span></span><br><span class="line"><span class="keyword">type</span> FlyBehavior <span class="keyword">interface</span> &#123;</span><br><span class="line">fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuackBehavior 呱呱叫行为接口</span></span><br><span class="line"><span class="keyword">type</span> QuackBehavior <span class="keyword">interface</span> &#123;</span><br><span class="line">quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyWithWings 会飞的类</span></span><br><span class="line"><span class="keyword">type</span> FlyWithWings <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(flyWithWings FlyWithWings)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"会飞"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FlyWithWings 不会飞的类</span></span><br><span class="line"><span class="keyword">type</span> FlyNoWay <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(flyNoWay FlyNoWay)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不会飞"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Quack 呱呱叫</span></span><br><span class="line"><span class="keyword">type</span> Quack <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(quack Quack)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"呱呱"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Squeak 吱吱叫</span></span><br><span class="line"><span class="keyword">type</span> Squeak <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(squeak Squeak)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"吱吱"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MuteQuack 不会叫</span></span><br><span class="line"><span class="keyword">type</span> MuteQuack <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(muteQuack MuteQuack)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"不会叫"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Duck 鸭子类</span></span><br><span class="line"><span class="keyword">type</span> Duck <span class="keyword">struct</span> &#123;</span><br><span class="line">FlyBehavior   FlyBehavior</span><br><span class="line">QuackBehavior QuackBehavior</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.FlyBehavior.fly() <span class="comment">// 委托给飞行行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Duck)</span> <span class="title">quack</span><span class="params">()</span></span> &#123;</span><br><span class="line">d.QuackBehavior.quack() <span class="comment">// 委托给呱呱叫行为</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">yellowDuck := Duck&#123;FlyNoWay&#123;&#125;, Squeak&#123;&#125;&#125;</span><br><span class="line">yellowDuck.fly()</span><br><span class="line">yellowDuck.quack()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">不会飞</span></span><br><span class="line"><span class="comment">吱吱</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三种设计原则：</p><ol><li>封装变化</li><li>多用组合，少用继承</li><li>针对接口编程，不针对实现编程</li></ol><p>注意此处的「针对接口编程」，书中也有强调：</p><blockquote><p>「针对接口编程」真正的意思是「针对超类型（supertype）编程」。这里所谓的「接口」有多个含义，接口是一个「概念」，也是一种 Java 的 interface 构造。你可以在不涉及 Java interface 的情况下「针对接口编程」，关键就在<strong>多态</strong>。利用多态，程序可以针对超类型编程，执行时会根据实际状况执行到真正的行为。</p></blockquote><p>因此，你不用拘泥于 <code>interface</code>，你所用的语言就算没有 <code>interface</code> 也能实现设计模式。</p>]]></content>
    
    <summary type="html">
    
      在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="设计模式" scheme="http://jalan.space/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>【译】SQL 将死于 No-SQL 之手？</title>
    <link href="http://jalan.space/2020/02/25/2020/is-no-sql-killing-sql/"/>
    <id>http://jalan.space/2020/02/25/2020/is-no-sql-killing-sql/</id>
    <published>2020-02-25T12:37:00.000Z</published>
    <updated>2021-01-19T11:30:38.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>原文地址：<a href="https://towardsdatascience.com/is-no-sql-killing-sql-3b0daff69ea" target="_blank" rel="noopener">Is No-SQL killing SQL?</a></li><li>原文作者：<a href="https://medium.com/@tjwaterman99" target="_blank" rel="noopener">Tom Waterman</a></li><li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li><li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/is-no-sql-killing-sql.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/is-no-sql-killing-sql.md</a></li><li>译者：<a href="http://jalan.space">江不知</a></li><li>校对者：<a href="https://github.com/cyz980908" target="_blank" rel="noopener">Jessica</a>, <a href="https://github.com/todaycoder001" target="_blank" rel="noopener">司徒公子</a></li></ul></blockquote><h1 id="SQL-将死于-No-SQL-之手？"><a href="#SQL-将死于-No-SQL-之手？" class="headerlink" title="SQL 将死于 No-SQL 之手？"></a>SQL 将死于 No-SQL 之手？</h1><p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707c6493cef6ae0?w=1344&amp;h=520&amp;f=png&amp;s=263767" alt=""></p><h4 id="SQL-永生不灭的两个原因"><a href="#SQL-永生不灭的两个原因" class="headerlink" title="SQL 永生不灭的两个原因"></a>SQL 永生不灭的两个原因</h4><p>上周，我的一位朋友向我转发了一封来自一位成功创业者的电子邮件，邮件宣称「SQL 已死」。</p><p>这位创业者宣称，像 MongoDB、Redis 这样广受欢迎的 No-SQL 数据库会慢慢取代基于 SQL 的数据库，因此，作为数据科学家还需学习 SQL 是一个「历史遗留问题」。</p><p>我完全被他的电子邮件震惊了：他怎么得出如此离谱的结论？但是这也使我感到好奇……别人是否也有可能被类似地误导了？这位企业家已经发展了大批追随者，且直言不讳 —— 那么新晋数据科学家是否已经收到了避免学习 SQL 的建议？</p><p>因此我觉得我应当公开分享我对该创业者的回应，以防他人认为 SQL 即将走向灭绝。</p><blockquote><p>在数据科学的职业生涯中，你<strong>绝对</strong>应当学习 SQL。No-SQL 的存在绝对不会影响学习 SQL 的价值。</p></blockquote><p>基本上有两个原因可以保证 SQL 在未来几十年仍然适用。</p><p><strong>原因 #1：No-SQL 数据库无法取代数据分析型数据库，例如 Presto、Redshift 或 BigQuery</strong></p><p>无论你的应用是使用以 SQL 为后端的数据库，例如 MySQL，或是以 No-SQL 为后端的数据库，例如 MongoDB，这些后端中的数据最终都将被加载到一个专用的数据分析数据库中，例如 Redshift、Snowflake、BigQuery 或 Presto。</p><p><img src="https://user-gold-cdn.xitu.io/2020/2/25/1707c64ab94efb07?w=1552&amp;h=778&amp;f=png&amp;s=140495" alt="分析型数据库平台架构示例：SQL 与 NoSQL"></p><p>为什么公司要将他们的数据转移到像 Redshift 这样特定的列式存储中？因为和 NoSQL 与 MySQL 这样的行式存储数据库相比，列式存储能<strong>更</strong>快地运行分析查询。事实上，我敢打赌，列式存储和 NoSQL 一样会越来越受欢迎。</p><p>因此，无论是 NoSQL 还是其他的应用程序数据库都与数据科学家无关，因为数据科学家不会对应用程序数据库进行操作（尽管有一些例外，这些例外我将在之后讨论）。</p><p><strong>原因 #2：No-SQL 数据库的好处不在于他们不支持 SQL 语言</strong></p><p>事实证明，如果 No-SQL 数据存储支持基于 SQL 的查询引擎是有意义的，那么它们就可以实现该引擎。类似地，SQL 数据库也可以支持 NoSQL 查询语言，但是它们选择不支持。</p><p>为什么列式存储<strong>有意选择</strong>提供 SQL 接口呢？</p><p>他们之所以作出这样的选择是因为 SQL 是一种表达数据操作指令的强大语言。</p><p>让我们来考虑一个简单的查询示例，该查询用于计算来自 NoSQL 数据库 MongoDB 中某集合的文档数量。</p><blockquote><p>注意：MongoDB 中的文档类似于行，集合类似于表。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">db.sales.aggregate( [</span><br><span class="line">  &#123;</span><br><span class="line">    $group: &#123;</span><br><span class="line">       _id: <span class="literal">null</span>,</span><br><span class="line">       count: &#123; <span class="attr">$sum</span>: <span class="number">1</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">] )</span><br></pre></td></tr></table></figure><p>将其与等价的 SQL 语句进行比较。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="number">1</span>) <span class="keyword">from</span> sales</span><br></pre></td></tr></table></figure><p>显然，对于想要提取数据的人来说，SQL 语言是更好的选择。（NoSQL 数据库支持另一种语言，因为对于与数据库连接的应用程序库来说，正确构造 SQL 相对比较困难）。</p><hr><p>在前面我提到过，应用程序数据库技术与科学家无关的规则是有例外的。例如，在我的第一家公司，我们实际上没有任何像 Redshift 这样的分析型数据库，所以我不得不直接查询该应用程序的数据库。（更准确地说，我是在查询应用程序数据库的只读副本）。</p><p>公司的应用也使用了 Redis 这样的 No-SQL 数据库，这样至少有一次，我需要从 Redis 中提取数据，所以我必须学习一些 Redis 的 NoSQL API 的某些组件。</p><p>因此，如果在主应用程序环境中完全使用 NoSQL 数据库，那么你学到的任何 SQL 知识都与之无关了。但是这样的环境非常少见，随着公司的发展，他们几乎都会把一个基于 SQL 的列式存储数据库投入使用。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      SQL 永生不灭的两个原因
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="翻译" scheme="http://jalan.space/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="数据库" scheme="http://jalan.space/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="SQL" scheme="http://jalan.space/tags/SQL/"/>
    
      <category term="No-SQL" scheme="http://jalan.space/tags/No-SQL/"/>
    
  </entry>
  
  <entry>
    <title>macOS 下 MongoDB 连接报错排查过程及处理</title>
    <link href="http://jalan.space/2020/01/31/2020/macos-mongodb-start-error/"/>
    <id>http://jalan.space/2020/01/31/2020/macos-mongodb-start-error/</id>
    <published>2020-01-31T12:37:00.000Z</published>
    <updated>2020-01-31T13:14:27.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 macOS 下使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 安装 MongoDB。但在 Homebrew 的核心库中，我们无法找到 MongoDB，于是需要先运行 <code>brew tap</code>，帮助我们扩大可安装软件的选择范围。</p><blockquote><p>The tap command allows Homebrew to tap into another repository of formulae. Once you’ve done this you’ve expanded your options of installable software.</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew tap mongodb/brew</span><br></pre></td></tr></table></figure><p>之后，运行如下命令安装 MongoDB：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew install mongodb-community@4.2</span><br></pre></td></tr></table></figure><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>使用 <code>brew</code> 命令运行 MongoDB：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew services start mongodb-community@4.2</span><br></pre></td></tr></table></figure><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>启动成功后，使用如下命令与 MongoDB 建立连接：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mongo</span><br></pre></td></tr></table></figure><p>运行命令后发现连接失败，错误如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MongoDB shell version v4.2.2</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb</span><br><span class="line">2020-01-31T19:24:23.752+0800 E  QUERY    [js] Error: couldn&apos;t connect to server 127.0.0.1:27017, connection attempt failed: SocketException: Error connecting to 127.0.0.1:27017 :: caused by :: Connection refused :</span><br><span class="line">connect@src/mongo/shell/mongo.js:341:17</span><br><span class="line">@(connect):2:6</span><br><span class="line">2020-01-31T19:24:23.768+0800 F  -        [main] exception: connect failed</span><br><span class="line">2020-01-31T19:24:23.768+0800 E  -        [main] exiting with code 1</span><br></pre></td></tr></table></figure><h3 id="报错排查"><a href="#报错排查" class="headerlink" title="报错排查"></a>报错排查</h3><p>看报错信息总之就是连接失败了，这么一大段除了 <code>Error connecting</code> 也没啥有用的信息了。为了获取<strong>具体</strong>的错误信息，我们可以查看 MongoDB 的日志文件，日志在 <em>/usr/local/var/log/mongodb</em> 目录中，日志信息如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat /usr/local/var/log/mongodb/mongo.log</span><br><span class="line">2020-01-31T20:20:11.840+0800 I  CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols &apos;none&apos;</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] MongoDB starting : pid=44665 port=27017 dbpath=/usr/local/var/mongodb 64-bit host=Jalan-JiangdeMacBook-Pro.local</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] db version v4.2.2</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] git version: a0bbbff6ada159e19298d37946ac8dc4b497eadf</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] allocator: system</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] modules: none</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] build environment:</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten]     distarch: x86_64</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten]     target_arch: x86_64</span><br><span class="line">2020-01-31T20:20:11.875+0800 I  CONTROL  [initandlisten] options: &#123; config: &quot;/usr/local/etc/mongod.conf&quot;, net: &#123; bindIp: &quot;127.0.0.1&quot; &#125;, storage: &#123; dbPath: &quot;/usr/local/var/mongodb&quot; &#125;, systemLog: &#123; destination: &quot;file&quot;, logAppend: true, path: &quot;/usr/local/var/log/mongodb/mongo.log&quot; &#125; &#125;</span><br><span class="line">2020-01-31T20:20:11.876+0800 I  STORAGE  [initandlisten]</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten] ** WARNING: Support for MMAPV1 storage engine has been deprecated and will be</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten] **          removed in version 4.2. Please plan to migrate to the wiredTiger</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten] **          storage engine.</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/deprecated-mmapv1</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten]</span><br><span class="line">2020-01-31T20:20:11.877+0800 I  STORAGE  [initandlisten] Detected data files in /usr/local/var/mongodb created by the &apos;mmapv1&apos; storage engine, so setting the active storage engine to &apos;mmapv1&apos;.</span><br><span class="line">2020-01-31T20:20:11.878+0800 I  STORAGE  [initandlisten] exception in initAndListen: Location18656: Cannot start server with an unknown storage engine: mmapv1, terminating</span><br><span class="line">2020-01-31T20:20:11.878+0800 I  NETWORK  [initandlisten] shutdown: going to close listening sockets...</span><br><span class="line">2020-01-31T20:20:11.878+0800 I  NETWORK  [initandlisten] removing socket file: /tmp/mongodb-27017.sock</span><br><span class="line">2020-01-31T20:20:11.878+0800 I  -        [initandlisten] Stopping further Flow Control ticket acquisitions.</span><br><span class="line">2020-01-31T20:20:11.879+0800 I  CONTROL  [initandlisten] now exiting</span><br><span class="line">2020-01-31T20:20:11.879+0800 I  CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure><p>列出关键信息：<em>WARNING: Support for MMAPV1 storage engine has been deprecated and will be removed in version 4.2. Please plan to migrate to the wiredTiger</em></p><p>翻译一下就是：<strong>4.2 版本已不再支持 MMAPV1 引擎，请迁移至 wiredTiger 引擎</strong>。</p><p>在 <a href="https://docs.mongodb.com/manual/release-notes/4.0-compatibility/#deprecate-mmapv1" target="_blank" rel="noopener">Compatibility Changes in MongoDB 4.0</a> 中我们可以看到，MongoDB 从 4.0 版本开始就不再支持 MMAPV1 引擎了（<em>Deprecate MMAPv1</em>），因此，我们需要把引擎切换成 wiredTiger。</p><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>首先，启动要切换引擎的 MongoDB：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brew services start mongodb-community@4.2</span><br></pre></td></tr></table></figure><p>如果这个数据库中还有你所需要的数据，需要使用 <code>mongodump</code> 对数据库进行备份。</p><p>然后，创建一个新的目录，用于 wiredTiger 引擎的数据存储。我创建的目录为：<em>/usr/local/varmongodb-w</em>。</p><p>最后，使用 wiredTiger 引擎启动 MongoDB：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mongod --storageEngine wiredTiger --dbpath /usr/local/varmongodb-w</span><br></pre></td></tr></table></figure><p>其中，<code>--dbpath</code> 后填写你刚才创建的新目录。</p><p>如果你刚才备份过数据，还需要使用 <code>mongorestore</code> 将数据重新导入。</p><p>大功告成啦~</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">Install MongoDB Community Edition on macOS</a></li><li><a href="https://docs.mongodb.com/manual/release-notes/4.0-compatibility/" target="_blank" rel="noopener">Compatibility Changes in MongoDB 4.0</a></li></ul>]]></content>
    
    <summary type="html">
    
      切换引擎至 WiredTiger
    
    </summary>
    
      <category term="跨过这道坎" scheme="http://jalan.space/categories/%E8%B7%A8%E8%BF%87%E8%BF%99%E9%81%93%E5%9D%8E/"/>
    
    
      <category term="mongodb" scheme="http://jalan.space/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>2019，冒险者的孤勇</title>
    <link href="http://jalan.space/2020/01/02/2020/2019-bye/"/>
    <id>http://jalan.space/2020/01/02/2020/2019-bye/</id>
    <published>2020-01-02T12:37:00.000Z</published>
    <updated>2020-01-25T14:34:00.852Z</updated>
    
    <content type="html"><![CDATA[<p>半个月前，我参加<a href="https://juejin.im/post/5def04e06fb9a01631780bec" target="_blank" rel="noopener">掘金年度征文</a>，写了一篇<a href="https://juejin.im/post/5df70c6cf265da33bd497c22" target="_blank" rel="noopener">《2019 年「我与技术那些事儿」| 掘金年度征文》</a>。这篇文章基本是我 2019 年在技术上的总结了。</p><p>但技术永远都只是生活的一部分。我不想在公众平台上写太多私人的事，所以还是按照以往的惯例，在博客上发一篇真正的、全面的 2019 年度总结。</p><p>2019 年 12 月的前半月我忙着发烧，后半月忙着制作 <a href="https://juejin.im/post/5e0aaa11e51d4575e942f14f" target="_blank" rel="noopener">GitHub 年度报告</a>，所以这篇「真正的总结」也只好放到 2020 年来写。</p><p>技术方面我就不再赘述了，如果你对我的技术总结感兴趣，欢迎戳上面的掘金链接。</p><p><img src="/img/in-post/2020/2019-bye/work.jpeg" alt="2019 年，在深圳"></p><h2 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h2><p>我给这篇年度总结起名《2019，冒险者的孤勇》，因为 2019 年对我而言就是冒险、承担、执拗。</p><p>年初冒险的决定改变了我的工作和生活，但我并没有因此而过得多好，反而时常为此流泪叹息。我一直很焦虑，时常自责。直到有一次，我的心理咨询师对我说：「你年初的决定很好地保护了你自己」。从此往后，我开始用这句话不段地自我鼓励：<strong>虽然我做得还不够好，但这个决定我从来没有做错过。就算没有人帮助我，我也可以保护好自己。</strong></p><p>「往者不可谏，来者犹可追」，这段冒险一旦开始就没有办法回头了。我在这条路上「又勇又怂」：勇在开疆扩土，怂在本性难移。「怂」的部分总是很难改变，但愿 2020 勇字当头，能活得更自在、更热忱些。</p><p><img src="/img/in-post/2020/2019-bye/shenzhen.jpeg" alt="2019 年 10 月，摄于福州南站"></p><h2 id="尝鲜"><a href="#尝鲜" class="headerlink" title="尝鲜"></a>尝鲜</h2><p>2019 年是「尝鲜」的一年，我经历了很多「人生第一次」：</p><ul><li>第一次裸辞</li><li>第一次「下岗」待业</li><li>第一次在深圳生活</li><li>第一次骑车上下班</li><li>第一次会网友</li><li>第一次心理咨询</li><li>第一次围观<a href="http://www.spartanrace.cn/zh/race/race-types/race-types-overview" target="_blank" rel="noopener">斯巴达勇士竞速赛</a></li><li>第一次自己坐飞机（还坐了 4 次）</li><li>第一次参加开发者大会（见<a href="http://jalan.space/2019/09/12/2019/google-developer-days/">《2019 谷歌开发者大会之我见》</a>）</li><li>第一次参与 GitHub 上的开源项目（<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>，<a href="https://github.com/PHPMailer/PHPMailer" target="_blank" rel="noopener">PHPMailer</a>，<a href="https://github.com/jackfrued/Python-100-Days" target="_blank" rel="noopener">Python-100-Days</a>）</li><li>第一次开发 iOS 应用</li><li>第一次维护自己的开源项目（<a href="https://github.com/JalanJiang/leetcode-notebook" target="_blank" rel="noopener">leetcode-notebook</a>）</li><li>第一次创建技术群组（<a href="https://github.com/leetcode-notebook" target="_blank" rel="noopener">刷题小组</a>），认识了很多志同道合的小伙伴</li><li>第一次运营微信公众号，因此结识了非常多的大佬</li><li>……</li></ul><p><img src="/img/in-post/2020/2019-bye/spartanrace.jpeg" alt="斯巴达勇士竞速赛观光团"></p><h2 id="行路"><a href="#行路" class="headerlink" title="行路"></a>行路</h2><p>2019 年我去了香港、潮汕、上海、广州、顺德和南浔。原本在下半年有出国的计划，但很遗憾，最终没有达成。</p><p><img src="/img/in-post/2020/2019-bye/nan-xun.jpeg" alt="2019 年 11 月，摄于南浔古镇"></p><p>2020 年依旧想去一些从未到达的城市，看看别人的生活。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>我在 2019 年悟出的一个道理是：<strong>凡事急不得</strong>。</p><p>我经常遇见想做的事就开始挖坑，却往往三分钟热度，最终都没能把坑填上，导致事后自责懊恼，自信心受挫。我总是着急着想做成一些事，却忘记了很多事是着急不得的。专心做一件事时，其实就不能专心做另一件事，要用沉浸的心态把一件事做好，才能最终尝到「延迟满足」的滋味。</p><p>很感谢 2019 年最后一天我完成了 <a href="https://github.com/JalanJiang/2019-github-annual-report" target="_blank" rel="noopener">GitHub 年度报告</a>，这不是什么大项目，但在完成的过程中我经历了热情、懈怠、疲倦、放弃、重拾、收获几个过程，可谓是跌宕起伏了。这个项目让我尝到了甜头，让我在回顾 2019 时对自己有了更多的自信，也让我学会了如何调整心态，让自己更积极地面对生活中的「困倦期」。</p><p>2019 年的最后一个月我病了很久，一次病毒性感冒让我在两周中反复发烧，三进医院，直到今天我还在咳嗽，这个病依旧没有好全。2020 年我会把身体管理放在首要位置，未来还很长，不能在年轻时就把革命的本钱提前消耗殆尽。</p><h2 id="感恩"><a href="#感恩" class="headerlink" title="感恩"></a>感恩</h2><p>2019 年来到深圳后结识了很多新朋友，其中不乏许多大佬和有趣的人。</p><p>非常感谢遇到了现在的神仙舍友，在生活上对我照顾颇多。</p><p><img src="/img/in-post/2020/2019-bye/birthday.jpeg" alt="舍友下厨为我庆生"></p><p>年初离开厦门后，我在年底顺利地和<a href="http://gagalee.ink/" target="_blank" rel="noopener">佳爷</a>、<a href="https://csming1995.github.io/" target="_blank" rel="noopener">少棉</a>又见上面。除此之外，今年也顺利地和王总、应总实现了「一年一聚」之约。</p><p>感谢所有的朋友 2019 年听我吐了一年的苦水，感恩一直有你们鼓励我、督促我、陪着我。祝所有朋友 2020 年能一切顺利，未来都过上自己想要的生活。</p><p><img src="/img/in-post/2020/2019-bye/nan-xun-01.jpeg" alt="劝君更尽一杯酒"></p><p>最后的最后，也感谢自己从未放弃过自己。</p><h2 id="拔剑吧，2020"><a href="#拔剑吧，2020" class="headerlink" title="拔剑吧，2020"></a>拔剑吧，2020</h2><p>跨年是一件颇具仪式感的事。</p><p>2019 年的最后一天，我和<a href="http://csming1995.github.io/" target="_blank" rel="noopener">少棉</a>在深圳一起度过了告别 20 世纪 10 年代的跨年夜。这是我们在深圳的第一次跨年，在深圳湾吹着海风，听着一群陌生人喊着倒计时的数字。深圳湾没有烟花表演，黑漆漆一片，在人才公园的入口亦看不见繁华的香港。但在零点到来的时刻，听着陌生人大喊着「新年快乐」，迎接 2020 的一霎那有种莫名的幸福。</p><p>少棉曾经对我说「我们终于活下来了」，我把这句话写到了跨年的朋友圈文案里，还写了一句「我们有一万个去冒险的梦想，2019 年终于实现了一个」。</p><p>2019 年真的太难了，但我们也曾在 2019 年感慨「2018 年太难」，似乎进入成年人的世界后就再没有舒坦的日子。</p><p>但那又如何？2019 死里逃生，还怕些什么呢？</p><p><strong>拔剑吧 2020，我怕你个球</strong>。</p>]]></content>
    
    <summary type="html">
    
      拔剑吧，2020
    
    </summary>
    
      <category term="少年人的冲动" scheme="http://jalan.space/categories/%E5%B0%91%E5%B9%B4%E4%BA%BA%E7%9A%84%E5%86%B2%E5%8A%A8/"/>
    
    
      <category term="生活啊" scheme="http://jalan.space/tags/%E7%94%9F%E6%B4%BB%E5%95%8A/"/>
    
  </entry>
  
  <entry>
    <title>手摸手制作一份 2019 年 GitHub 年度报告</title>
    <link href="http://jalan.space/2019/12/31/2019/2019-github-annual-report/"/>
    <id>http://jalan.space/2019/12/31/2019/2019-github-annual-report/</id>
    <published>2019-12-31T12:28:00.000Z</published>
    <updated>2020-01-02T12:35:16.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们即将与 2019 挥手作别，踏入崭新的 2020。一到年末，各个平台都在整理数据，出具一份属于自己平台的「年度报告」。而对于技术人而言，如果你是一位开源爱好者，GitHub 的年度报告就是你 2019 年的技术总结。</p><p>阮一峰老师曾在<a href="https://www.ruanyifeng.com/blog/2019/09/weekly-issue-73.html" target="_blank" rel="noopener">科技爱好者周刊</a>中提到「数据的力量」：</p><blockquote><p>GitHub 个人页有一个日历栏目，只要当天有代码提交，那一天的小方格就会变成绿色。如果这一年，你每天编码，日历就全是绿的，否则就会有白色的小方块。所有人都可以看到这个「编码日历」。很多人为了让绿色小方格子不要中断，就会尽量每天提交代码。时间一长，真的多做了不少项目。</p></blockquote><p>因此，这次年度报告我想主要针对这份「编码日历」，把你的「编码日历」组装到一张图片上展示给别人。</p><p>因为前一段时间正好在学习 <a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL</a>，所以将通过 GitHub 的接口 <a href="https://developer.github.com/v4/" target="_blank" rel="noopener">GitHub GraphQL API v4</a> 来获取相关的用户数据。</p><p>这份年度报告涉及到的主要技术：</p><ul><li>GraphQL</li><li>Python<ul><li><a href="https://2.python-requests.org//zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">requests</a>（发起请求）</li><li><a href="https://github.com/python-pillow/Pillow" target="_blank" rel="noopener">PIL</a>: Image/ImageDraw/ImageFont（图片处理）</li><li><a href="https://github.com/offu/WeRoBot" target="_blank" rel="noopener">werobot</a>（接入微信公众号）</li></ul></li></ul><h2 id="需求确立"><a href="#需求确立" class="headerlink" title="需求确立"></a>需求确立</h2><p>在开始 Coding 之前需要先梳理一下需求。生成报告的整个流程大致如下：</p><p><img src="/img/in-post/2019-github-annual-report/flow.png" alt="项目流程图"></p><p>因此，需要做的事包括：</p><ol><li>调通 GitHub GraphQL API v4，获取到需要的数据</li><li>对数据进行统计整理</li><li>设计一份年度报告</li><li>结合整理后的数据生成报告，并将最终报告返回给用户</li><li>接入微信公众平台，走通整个流程</li></ol><h2 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h2><h3 id="何为-GraphQL？"><a href="#何为-GraphQL？" class="headerlink" title="何为 GraphQL？"></a>何为 GraphQL？</h3><p>因为要通过 GitHub GraphQL API v4 获取数据，所以先来聊聊 GraphQL。</p><p>官方对于 GraphQL 的定义是：</p><blockquote><p>一种用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。</p></blockquote><p>这样说很抽象，大家可能对 <a href="https://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">RESTful</a> 比较熟悉些，那么我们就拿 <a href="">GitHub REST API v3</a> 与 GitHub GraphQL API v4 获取数据的方式做一个简单的对比，GraphQL 的特点自然就一目了然。</p><p>以获取用户数据为例，相关接口文档：</p><ul><li>REST API v3: Users：<a href="https://developer.github.com/v3/users/" target="_blank" rel="noopener">https://developer.github.com/v3/users/</a></li><li>GraphQL API v4: User：<a href="https://developer.github.com/v4/object/user/" target="_blank" rel="noopener">https://developer.github.com/v4/object/user/</a></li></ul><p>对于 RESTful 风格而言，自然是要发起一个 <code>GET</code> 请求。由于我们要获取某个<strong>指定用户</strong>的数据，所以需要在 PATH 中指定 <code>:username</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /users/:username</span><br></pre></td></tr></table></figure><p>请求成功后 GitHub 将会返回以下数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"login"</span>: <span class="string">"octocat"</span>,</span><br><span class="line">  <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"node_id"</span>: <span class="string">"MDQ6VXNlcjE="</span>,</span><br><span class="line">  <span class="attr">"avatar_url"</span>: <span class="string">"https://github.com/images/error/octocat_happy.gif"</span>,</span><br><span class="line">  <span class="attr">"gravatar_id"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"https://api.github.com/users/octocat"</span>,</span><br><span class="line">  <span class="attr">"html_url"</span>: <span class="string">"https://github.com/octocat"</span>,</span><br><span class="line">  <span class="attr">"followers_url"</span>: <span class="string">"https://api.github.com/users/octocat/followers"</span>,</span><br><span class="line">  <span class="attr">"following_url"</span>: <span class="string">"https://api.github.com/users/octocat/following&#123;/other_user&#125;"</span>,</span><br><span class="line">  <span class="attr">"gists_url"</span>: <span class="string">"https://api.github.com/users/octocat/gists&#123;/gist_id&#125;"</span>,</span><br><span class="line">  <span class="attr">"starred_url"</span>: <span class="string">"https://api.github.com/users/octocat/starred&#123;/owner&#125;&#123;/repo&#125;"</span>,</span><br><span class="line">  <span class="attr">"subscriptions_url"</span>: <span class="string">"https://api.github.com/users/octocat/subscriptions"</span>,</span><br><span class="line">  <span class="attr">"organizations_url"</span>: <span class="string">"https://api.github.com/users/octocat/orgs"</span>,</span><br><span class="line">  <span class="attr">"repos_url"</span>: <span class="string">"https://api.github.com/users/octocat/repos"</span>,</span><br><span class="line">  <span class="attr">"events_url"</span>: <span class="string">"https://api.github.com/users/octocat/events&#123;/privacy&#125;"</span>,</span><br><span class="line">  <span class="attr">"received_events_url"</span>: <span class="string">"https://api.github.com/users/octocat/received_events"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"User"</span>,</span><br><span class="line">  <span class="attr">"site_admin"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"monalisa octocat"</span>,</span><br><span class="line">  <span class="attr">"company"</span>: <span class="string">"GitHub"</span>,</span><br><span class="line">  <span class="attr">"blog"</span>: <span class="string">"https://github.com/blog"</span>,</span><br><span class="line">  <span class="attr">"location"</span>: <span class="string">"San Francisco"</span>,</span><br><span class="line">  <span class="attr">"email"</span>: <span class="string">"octocat@github.com"</span>,</span><br><span class="line">  <span class="attr">"hireable"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"bio"</span>: <span class="string">"There once was..."</span>,</span><br><span class="line">  <span class="attr">"public_repos"</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">"public_gists"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"followers"</span>: <span class="number">20</span>,</span><br><span class="line">  <span class="attr">"following"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"created_at"</span>: <span class="string">"2008-01-14T04:33:35Z"</span>,</span><br><span class="line">  <span class="attr">"updated_at"</span>: <span class="string">"2008-01-14T04:33:35Z"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但有时我们不需要这么多的数据，我们可能只想获取用户的头像地址。在 RESTful 风格的接口下，我们无法只获取某一条数据，但对于 GraphQL 接口，我们可以发起这样一条请求：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    user(login: "username") &#123;</span><br><span class="line">        avatarUrl</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，服务端将根据我们请求数据的格式，返回给我们对应的字段，即仅返回 <code>user</code> 下的 <code>avatarUrl</code> 数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"user"</span>:&#123;</span><br><span class="line">            <span class="attr">"avatarUrl"</span>:<span class="string">"url"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 RESTful 中，我们被迫接收服务端已组装好的数据，但 GraphQL 给了我们更多的自由，让我们可以只取所需。</strong></p><p>除此之外，RESTful 以资源划分接口，数据之间相对离散，如果想请求不同的资源则需要发起多次请求。而 GraphQL 的数据更具整体性，资源之间以<strong>图</strong>（即 Graph 名称的由来）的形式彼此关联，一次请求即可获取多种资源。</p><h3 id="构造-GraphQL-请求"><a href="#构造-GraphQL-请求" class="headerlink" title="构造 GraphQL 请求"></a>构造 GraphQL 请求</h3><p>我想要获取的数据主要有：</p><ol><li>用户名</li><li>用户在 2019 年每日的贡献情况</li><li>用户 Followers 数量</li></ol><p>根据接口文档 <a href="https://developer.github.com/v4/object/user/" target="_blank" rel="noopener">User</a> 与  <a href="https://developer.github.com/v4/object/contributionscollection/" target="_blank" rel="noopener">ContributionsCollection</a> 可知，这些数据都在 <code>user</code> 中，对应的字段如下：</p><ul><li>用户昵称：<code>name</code></li><li>Followers 数量：<code>followers.totalCount</code></li><li>编码日历：<code>contributionsCollection.contributionCalendar</code><ul><li>总贡献数量：<code>totalContributions</code></li><li>每周贡献情况：<code>weeks</code><ul><li>每日贡献情况：<code>contributionDays</code><ul><li>当天日历颜色：<code>color</code></li><li>当天贡献数：<code>contributionCount</code></li><li>当天日期：<code>date</code></li></ul></li></ul></li></ul></li></ul><p>因此，可以构造出如下 <code>query</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">query = <span class="string">"""</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    user(login: "%s") &#123;</span></span><br><span class="line"><span class="string">        followers &#123;</span></span><br><span class="line"><span class="string">            totalCount</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        name</span></span><br><span class="line"><span class="string">        contributionsCollection(</span></span><br><span class="line"><span class="string">            from: "%s",</span></span><br><span class="line"><span class="string">            to: "%s"</span></span><br><span class="line"><span class="string">        ) &#123;</span></span><br><span class="line"><span class="string">            contributionCalendar &#123;</span></span><br><span class="line"><span class="string">                totalContributions</span></span><br><span class="line"><span class="string">                weeks &#123;</span></span><br><span class="line"><span class="string">                    contributionDays &#123;</span></span><br><span class="line"><span class="string">                        color</span></span><br><span class="line"><span class="string">                        contributionCount</span></span><br><span class="line"><span class="string">                        date</span></span><br><span class="line"><span class="string">                    &#125;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string">"""</span>% (github_id, begin, end)</span><br></pre></td></tr></table></figure><p>构造好 <code>query</code> 后，我们使用 <code>requests</code> 发起请求：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access_token = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 请求 headers 带上 access_token</span></span><br><span class="line">headers = &#123;<span class="string">"Authorization"</span>: <span class="string">"bearer %s"</span> % access_token&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起请求</span></span><br><span class="line">response = requests.post(</span><br><span class="line">    <span class="string">"https://api.github.com/graphql"</span>,</span><br><span class="line">    headers=headers,</span><br><span class="line">    json=&#123;<span class="string">'query'</span>: query&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>若请求成功，GitHub 会返回如下格式的 JSON 数据：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"data"</span>:&#123;</span><br><span class="line">        <span class="attr">"user"</span>:&#123;</span><br><span class="line">            <span class="attr">"name"</span>:<span class="string">"江不知"</span>,</span><br><span class="line">            <span class="attr">"followers"</span>:&#123;</span><br><span class="line">                <span class="attr">"totalCount"</span>:<span class="number">71</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"contributionsCollection"</span>:&#123;</span><br><span class="line">                <span class="attr">"contributionCalendar"</span>:&#123;</span><br><span class="line">                    <span class="attr">"totalContributions"</span>:<span class="number">2234</span>,</span><br><span class="line">                    <span class="attr">"weeks"</span>:[</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="attr">"contributionDays"</span>:[</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="attr">"color"</span>:<span class="string">"#c6e48b"</span>,</span><br><span class="line">                                    <span class="attr">"contributionCount"</span>:<span class="number">30</span>,</span><br><span class="line">                                    <span class="attr">"date"</span>:<span class="string">"2019-01-01"</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h2><p>我主要针对 <code>weeks</code> 做了一些简单的数据统计。主要包括：</p><ul><li>有提交代码的天数（<code>contributionCount &gt; 0</code>）</li><li>连续提交代码的最大天数</li><li>完成贡献次数最多的日期</li></ul><p>这些数据对 <code>weeks</code> 进行一次遍历即可得出，在此不多做赘述。</p><h2 id="设计报告"><a href="#设计报告" class="headerlink" title="设计报告"></a>设计报告</h2><p>作为一个后端开发，真的没有多少设计天赋，说多了都是泪……</p><p>整份报告大致分成三个区域：</p><ol><li>头部 Title</li><li>Title 下的「编码日历」</li><li>中间部分显示一些分析数据</li><li>底部宣示主权</li></ol><p>反反复复改了多版，询问了很多朋友的意见，最后的结果依旧不是很好看……</p><p><img src="/img/in-post/2019-github-annual-report/template.png" alt="年度报告设计最终版"></p><h2 id="数据拼接"><a href="#数据拼接" class="headerlink" title="数据拼接"></a>数据拼接</h2><p>报告设计完成以后就可以把最终要展示的数据拼接到报告上了。</p><h3 id="绘制「编码日历」"><a href="#绘制「编码日历」" class="headerlink" title="绘制「编码日历」"></a>绘制「编码日历」</h3><p>在遍历 <code>weeks</code> 统计数据的过程中，可以顺便完成「编码日历」的绘制。</p><p>「编码日历」中的每一天就是一个小方块，方块的颜色我们已经从接口返回数据的 <code>color</code> 字段中获取到了。我选择使用 <code>line()</code> 绘制一条颜色为 <code>color</code> 的直线代表方块，把直线的 <code>width</code> 加粗，以获得方块的效果。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line">f = open(self.IMAGE_FILE_PATH, <span class="string">'rb'</span>)</span><br><span class="line">image = Image.open(f)</span><br><span class="line"><span class="comment"># 创建一个 draw 实例</span></span><br><span class="line">drawImage = ImageDraw.Draw(image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每周数据</span></span><br><span class="line"><span class="keyword">for</span> week <span class="keyword">in</span> weeks:</span><br><span class="line">    <span class="comment"># 遍历每日数据</span></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> week[<span class="string">'contributionDays'</span>]:</span><br><span class="line">        <span class="comment"># 取出当天的颜色</span></span><br><span class="line">        color = day[<span class="string">'color'</span>] </span><br><span class="line">        <span class="comment"># 绘制直线</span></span><br><span class="line">        drawImage.line([(x_point, y_point), (x_point + square_width, y_point)], fill=color, width=square_width)</span><br><span class="line">        <span class="comment"># 改变下一个方格的 y 坐标</span></span><br><span class="line">        y_point += move_width</span><br><span class="line">    <span class="comment"># 改变下一个方格的 x 坐标</span></span><br><span class="line">    x_point += move_width</span><br><span class="line">    <span class="comment"># 下一周开始，y 坐标恢复原处</span></span><br><span class="line">    y_point = y_begin</span><br></pre></td></tr></table></figure><h3 id="粘贴文字"><a href="#粘贴文字" class="headerlink" title="粘贴文字"></a>粘贴文字</h3><p>报告的其他部分就主要是文字内容了，设置好字体、颜色等，使用 <code>text()</code> 在指定位置贴上文字。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont</span><br><span class="line"></span><br><span class="line">font_size = <span class="number">60</span></span><br><span class="line"><span class="comment"># 设置字体与字号</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">"./font/fzlt.ttf"</span>, font_size)</span><br><span class="line">font_color = <span class="string">"#F7FFF7"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标</span></span><br><span class="line">x, y = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在图片写上文字</span></span><br><span class="line">draImage.text((x, y), <span class="string">"要显示的文字"</span>, fill=font_color, font=font)</span><br></pre></td></tr></table></figure><h2 id="接入公众号"><a href="#接入公众号" class="headerlink" title="接入公众号"></a>接入公众号</h2><p>公众号方面直接使用了开发框架 <a href="https://github.com/offu/WeRoBot" target="_blank" rel="noopener">WeRoBot</a>。</p><p>设定：当用户发送信息为「2019 $github_id」时触发生成年度报告。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot</span><br><span class="line"></span><br><span class="line">robot = werobot.WeRoBot(token=<span class="string">'token'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回复包含指定文本的信息</span></span><br><span class="line"><span class="meta">@robot.filter(re.compile("2019(\s)+(.*)?"))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">annual_report</span><span class="params">(message, session, match)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> match:</span><br><span class="line">        <span class="comment"># do something...</span></span><br></pre></td></tr></table></figure><p>生成年度报告后，我们使用微信的<a href="https://developers.weixin.qq.com/doc/offiaccount/Asset_Management/New_temporary_materials.html" target="_blank" rel="noopener">新增临时素材</a>接口上传报告图片，并获取到临时素材的编号 <code>media_id</code>：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werobot.client <span class="keyword">import</span> Client</span><br><span class="line"></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">"APP_ID"</span>: <span class="string">"app_id"</span>,</span><br><span class="line">    <span class="string">"APP_SECRET"</span>: <span class="string">"app_secret"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client = Client(config)</span><br><span class="line"><span class="comment"># 上传临时素材</span></span><br><span class="line">response = client.upload_media(<span class="string">'image'</span>, image) <span class="comment"># image 为生成的报告图片</span></span><br><span class="line"><span class="comment"># 获取临时素材 ID</span></span><br><span class="line">media_id = response[<span class="string">'media_id'</span>]</span><br></pre></td></tr></table></figure><p>然后，我们再将这一图片信息返回给用户：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> werobot.replies <span class="keyword">import</span> ImageReply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要返回的图片数据</span></span><br><span class="line">reply = ImageReply(message=message, media_id=media_id)</span><br><span class="line"><span class="keyword">return</span> reply</span><br></pre></td></tr></table></figure><h2 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h2><p>当用户在公众号发送 <code>2019+空格+github_id</code> 时，将返回 <code>github_id</code> 所对应的报告。最终生成的报告如下：</p><p><img src="/img/in-post/2019-github-annual-report/result.png" alt="我的 2019 GitHub 年度报告"></p><p>源码见 GitHub 仓库：<a href="https://github.com/JalanJiang/2019-github-annual-report" target="_blank" rel="noopener">https://github.com/JalanJiang/2019-github-annual-report</a></p><p>接入的服务器为辣鸡配置，还请各位大佬手下留情。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>整个过程涉及到微信公众号和 GitHub 接口的调用，用户从输入到数据返回需要等待几秒的时间。为了避免超时的尴尬情况，这里只对用户提交记录做了简单的分析。</p><p>在完成这个项目的过程中几度因为设计出的报告太丑而想要放弃，感谢几位朋友一直鼓励我、给我提出修改意见才让我坚持了下来。</p><p>2019 年再见啦，希望 2020 年能尝试更多有趣的事情。:)</p>]]></content>
    
    <summary type="html">
    
      你有一份 2019 年技术总结待查收
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Python" scheme="http://jalan.space/tags/Python/"/>
    
      <category term="GitHub" scheme="http://jalan.space/tags/GitHub/"/>
    
      <category term="GraphQL" scheme="http://jalan.space/tags/GraphQL/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法与正确性归纳证明</title>
    <link href="http://jalan.space/2019/12/11/2019/greedy/"/>
    <id>http://jalan.space/2019/12/11/2019/greedy/</id>
    <published>2019-12-11T15:05:00.000Z</published>
    <updated>2019-12-11T15:12:35.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>贪心算法就是让计算机模拟一个「贪心的人」来做出决策。这个贪心的人是目光短浅的，他每次总是：</p><ul><li>只做出<strong>当前看来最好的选择</strong></li><li><strong>只看眼前的利益，而不考虑做出选择后对未来造成的影响</strong></li></ul><p>并且他一旦做出了选择，就没有办法反悔（不可回溯），所以为了利益最大化，他需要保证绝不能做出错误的选择。</p><p>贪心算法不是从整体最优的角度上考虑问题，而是只在意某种意义上的局部最优解。因此，贪心算法并不能保证在所有情况下都能获得最优解。所以在使用贪心算法时，<strong>我们需要确保自己能证明最优解的正确性</strong>。</p><h2 id="贪心性质"><a href="#贪心性质" class="headerlink" title="贪心性质"></a>贪心性质</h2><p>可以用贪心算法解决的题目需要满足以下性质：</p><ul><li>最优子结构：一个问题的最优解包含其子问题的最优解</li><li>贪心选择性：所求问题的整体最优解可以通过一系列局部最优的选择来到达，即通过贪心选择来达到</li></ul><h2 id="证明方法"><a href="#证明方法" class="headerlink" title="证明方法"></a>证明方法</h2><p><strong>贪心算法最难的部分从不在于问题的求解，而在于正确性的证明</strong>，常用的证明方法有<strong>归纳法</strong>和<strong>交换论证法</strong>。</p><ul><li>归纳法：对算法进行<strong>步数归纳</strong>或<strong>问题规模归纳</strong></li><li>交换论证法：从最优解出发，在保证最优性不变的前提下，从一个最优解进行逐步替换，从而得到贪心策略的解</li></ul><p>因篇幅有限，本篇我们主要说说归纳证明。归纳证明的本质其实就是<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95" title="数学归纳法" target="_blank" rel="noopener">数学归纳法</a>，我们先来复习下数学归纳法吧。</p><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p>数学归纳法（<em>Mathematical Induction</em>）是一种<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E5%AD%B8%E8%AD%89%E6%98%8E" title="数学证明" target="_blank" rel="noopener">数学证明</a>方法，通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立。</p><h3 id="证明步骤"><a href="#证明步骤" class="headerlink" title="证明步骤"></a>证明步骤</h3><p>最简单和常见的数学归纳法是证明当 n 等于任意一个自然数时某命题成立。证明分下面两步：</p><ol><li>证明当 <code>n = 1</code> 时，命题成立</li><li>证明如果在 <code>n = m</code>（m 为任意自然数）时命题成立，那么可以推导出 <code>n = m + 1</code> 时命题也成立</li></ol><p><strong>1 为归纳基础，2 为归纳步骤</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>该方法的原理在于：一旦我们证明了在某个起点值（例如 <code>n = 1</code>）时命题成立，且证明出从一个值到下一个值的过程有效（即 <code>n = m</code> 到 <code>n = m + 1</code>），那么任意值都可以通过反复使用这个方法推导出来。即：</p><p>$$P(1) 为真，$$</p><p>$$且 \forall n, P(n) 为真 \to P(n + 1) 为真$$</p><p>那么：</p><p>$$n = 1, P(1) 为真 \to P(2) 为真$$</p><p>$$n = 2, P(2) 为真 \to P(3) 为真$$</p><p>$$……$$</p><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><p>如果我们要证明对于任意自然数，都满足：</p><p>$$1 + 2 + … + n = \frac {n \times (1 + n)}{2}$$</p><h4 id="归纳基础"><a href="#归纳基础" class="headerlink" title="归纳基础"></a>归纳基础</h4><p>找到起始点，即 <code>n = 1</code> 时，此时等式左侧等于 1，右侧等于：</p><p>$$\frac {1 \times (1 + 1)}{2} = \frac {2}{2} = 1$$</p><p>左右两侧相等，因此在 <code>n = 1</code> 时，命题成立。</p><h4 id="归纳步骤"><a href="#归纳步骤" class="headerlink" title="归纳步骤"></a>归纳步骤</h4><p>先假设：对于任意自然数 n 命题均成立。</p><p>那么，当 <code>n = n + 1</code> 时：</p><p>$$1 + 2 + … + (n + 1)$$</p><p>$$= (1 + 2 + … + n) + (n + 1)$$</p><p>$$= \frac {n \times (1 + n)}{2} + (n + 1)$$</p><p>$$= \frac {n \times (1 + n)}{2} + \frac{2 \times (n + 1)}{2}$$</p><p>$$= \frac{(n + 1) \times (n + 2)}{2}$$</p><p>因此，在 <code>n = n + 1</code> 时，命题也成立。证毕。</p><h2 id="算法正确性归纳证明"><a href="#算法正确性归纳证明" class="headerlink" title="算法正确性归纳证明"></a>算法正确性归纳证明</h2><p>归纳证明的证明步骤如下：</p><ol><li>叙述一个有关自然数 <code>n</code> 的命题，该命题断定贪心策略的执行最终将导致最优解，其中自然数 <code>n</code> 可以代表<strong>算法步数</strong>或者<strong>问题规模</strong>。</li><li>证明该问题对所有自然数为真</li></ol><p>其中，步骤二使用数学归纳法证明，即践行归纳基础与归纳步骤。</p><p>下面我们就来看下如何使用归纳法来证明 Kruskal 算法的正确性。</p><h2 id="Kruskal-最小生成树"><a href="#Kruskal-最小生成树" class="headerlink" title="Kruskal 最小生成树"></a>Kruskal 最小生成树</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95" title="Kruskal 算法" target="_blank" rel="noopener">Kruskal 算法</a>是一种常见并且好写的<a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91" title="最小生成树" target="_blank" rel="noopener">最小生成树</a>算法，由 Kruskal 发明。该算法基于贪心思想，基本思想是<strong>从小到大加入边</strong>。</p><h3 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h3><ol><li>将图的<strong>边按权值大小</strong>从小到大依次选取</li><li>选取权值最小的边 edge，假设构成该边的两个点为 (point1, point2)，如果 point1 和 point2 已在一个连通图中，则舍弃该边；否则讲该边加入最小生成树中</li><li>重复步骤 2，直到构成最小生成树为止</li></ol><p><img src="/img/in-post/greedy.gif" alt="图源：维基百科"></p><h3 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h3><h4 id="叙述命题"><a href="#叙述命题" class="headerlink" title="叙述命题"></a>叙述命题</h4><p>首先，给出命题：对于任意 n，该算法对 n 阶图都能得到一棵最小生成树。</p><h4 id="归纳基础-1"><a href="#归纳基础-1" class="headerlink" title="归纳基础"></a>归纳基础</h4><p>当 <code>n = 2</code> 时，此时只有一条边，命题显然为真。</p><h4 id="归纳步骤-1"><a href="#归纳步骤-1" class="headerlink" title="归纳步骤"></a>归纳步骤</h4><p>假设对于 n 个顶点的图，该算法正确，考虑 n + 1 个定点的图 $G$，假设 $G$ 中最小边权为 $e = {i, j}$。</p><p>此时，在图 $G$ 中连接点 $i$ 与点 $j$，得到图 $G’$。</p><p>根据归纳假设，由算法可推出：存在 $G’$ 的最小生成树 $T’$。令 $T = T’ \bigcup {e}$，则 $T$ 是关于 $G$ 的最小生成树。</p><p><strong>反证</strong>：若 $T$ 不是 $G$ 的最小生成树，那么必然存在某包含 $e$ 边的最小生成树 $T^<em>$，使得 $W(T^</em>) &lt; W(T)$（即 $T^*$ 的边权小于 $T$）。</p><p>此时，在 $T^<em>$ 中删除 $e$ 边，可得到 G’ 的最小生成树 $T^</em> - {e}$，且有：</p><p>$$<br>W(T^* - {e}) =</p><p>W(T^*) - w(e) &lt;</p><p>W(T) - w(e) =</p><p>W(T’)<br>$$</p><p>该表达式与 $T’$ 是最优解相互矛盾，所以 $T$ 必然是 $G$ 的最小生成树，证毕。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>贪心算法不是从整体最优的角度上考虑问题，而是只考虑某种意义上的局部最优解，不可回溯，不考虑后果</li><li>可以用贪心解答的题目需要满足<strong>最优子结构</strong>与<strong>贪心选择性</strong></li><li>贪心算法并不能保证在所有情况下都能获得最优解，所以在使用贪心算法时需要证明算法的正确性，常见的证明方法有<strong>归纳法</strong>与<strong>交换论证法</strong></li><li>数学归纳法通常被用于证明某个给定命题在整个（或者局部）自然数范围内成立，证明过程为<strong>归纳基础</strong>+<strong>归纳步骤</strong></li><li>归纳证明需先给出命题，再用数学归纳法证明该命题对所有自然数为真</li></ul><p><img src="/img/qrcode/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      贪心算法最难的部分从不在于问题的求解，而在于正确性的证明。
    
    </summary>
    
      <category term="技多不压身" scheme="http://jalan.space/categories/%E6%8A%80%E5%A4%9A%E4%B8%8D%E5%8E%8B%E8%BA%AB/"/>
    
    
      <category term="算法" scheme="http://jalan.space/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Go 语言中的面向对象编程</title>
    <link href="http://jalan.space/2019/12/02/2019/go-oop/"/>
    <id>http://jalan.space/2019/12/02/2019/go-oop/</id>
    <published>2019-12-02T12:40:00.000Z</published>
    <updated>2019-12-02T12:40:48.450Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道，在 Go 语言中没有类（Class）的概念，但这并不意味着 Go 语言不支持<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1" title="面向对象编程" target="_blank" rel="noopener">面向对象编程</a>，毕竟面向对象只是一种编程思想。</p><p>让我们回忆一下面向对象的三大基本特征：</p><ol><li>封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式</li><li>继承：使得子类具有父类的属性和方法或者重新定义、追加属性和方法等</li><li>多态：不同对象中同种行为的不同实现方式</li></ol><p>我们一起来看看 Go 语言是如何在没有类（Class）的情况下实现这三大特征的。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="「类」"><a href="#「类」" class="headerlink" title="「类」"></a>「类」</h3><p>在 Go 语言中可以使用<a href="https://gobyexample.com/structs" title="结构体" target="_blank" rel="noopener">结构体</a>（<em>Structs</em>）对属性进行封装，结构体就像是类的一种简化形式。</p><p>例如，我们要定义一个矩形，每个矩形都有长和宽，我们可以这样进行封装：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Width <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>既然有了「类」，你可能会问了，那「类」的<strong>方法</strong>在哪呢？</p><p>Go 语言中也有<a href="https://gobyexample.com/methods" title="方法" target="_blank" rel="noopener">方法</a>（<em>Methods</em>）：<strong>Go 方法是作用在接收者（<em>receiver</em>）上的一个函数，接收者是某种类型的变量。因此方法是一种特殊类型的函数。</strong></p><p>定义方法的格式如下：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(recv receiver_type)</span> <span class="title">methodName</span><span class="params">(parameter_list)</span> <span class="params">(return_value_list)</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>上文中我们已经定义了一个矩形 <code>Rectangle</code>，现在我们要定义一个方法 <code>Area()</code> 来计算它的面积：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩形结构体</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Width  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算矩形面积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Length * r.Width</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := Rectangle&#123;<span class="number">4</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">// 调用 Area() 方法，计算面积</span></span><br><span class="line">fmt.Println(r.Area())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段输出结果为 8。</p><h3 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h3><p>我们常会说一个类的属性是<strong>公共</strong>的还是<strong>私有</strong>的，在其他编程语言中，我们常用 <code>public</code> 与 <code>private</code> 关键字来表达这样一种访问权限。</p><p>在 Go 语言中没有 <code>public</code>、<code>private</code>、<code>protected</code> 这样的访问控制修饰符，它是<strong>通过字母大小写来控制可见性</strong>的。</p><p>如果定义的常量、变量、类型、接口、结构、函数等的名称是大写字母开头，这表示它们能被<strong>其它包</strong>访问或调用（相当于 <code>public</code>）；非大写开头就只能在<strong>包内使用</strong>（相当于 <code>private</code>）。</p><h3 id="访问未导出字段"><a href="#访问未导出字段" class="headerlink" title="访问未导出字段"></a>访问未导出字段</h3><p>当遇到<strong>只能在包内使用的未导出字段</strong>时，我们又该如何访问呢？</p><p>和其他面向对象语言一样，Go 语言也有实现 <code>getter</code> 和 <code>setter</code> 的方式：</p><ul><li>对于 <code>setter</code> 方法使用 <code>Set</code> 前缀</li><li>对于 <code>getter</code> 方法<strong>只使用成员名</strong></li></ul><p>例如我们现在有一个处于 <code>person</code> 包中的 <code>Person</code> 结构体：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> person</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">firstName <span class="keyword">string</span></span><br><span class="line">lastName  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，它的两个成员变量都是<strong>非大写字母开头</strong>，只能在包内使用，现在我们为其中的 <code>firstName</code> 来定义 <code>setter</code> 与 <code>getter</code> ：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 firstName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">FirstName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> p.firstName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 firstName</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Person)</span> <span class="title">SetFirstName</span><span class="params">(newName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">p.firstName = newName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，我们就可以在 <code>main</code> 包里设置和获取 <code>firstName</code> 的值了：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"./person"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">p := <span class="built_in">new</span>(person.Person)</span><br><span class="line">p.SetFirstName(<span class="string">"firstName"</span>)</span><br><span class="line">fmt.Println(p.FirstName())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">firstName</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>在 Go 语言中没有 <code>extends</code> 关键字，它使用<strong>在结构体中内嵌匿名类型</strong>的方法来实现继承。</p><blockquote><p>匿名类型：即这些类型没有显式的名字。</p></blockquote><p>我们定义一个 <code>Engine</code> 接口类型，一个 <code>Car</code> 结构体，让 <code>Car</code> 结构体包含一个 <code>Engine</code> 类型的匿名字段：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Engine <span class="keyword">interface</span> &#123;</span><br><span class="line">Start()</span><br><span class="line">Stop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Car <span class="keyword">struct</span> &#123;</span><br><span class="line">Engine <span class="comment">// 包含 Engine 类型的匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，匿名字段 <code>Engine</code> 上的方法「<strong>晋升</strong>」成为了外层类型 <code>Car</code> 的方法。我们可以构建出如下代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Car)</span> <span class="title">GoToWorkIn</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// get in car</span></span><br><span class="line">c.Start()</span><br><span class="line"><span class="comment">// drive to work</span></span><br><span class="line">c.Stop()</span><br><span class="line"><span class="comment">// get out of car</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>在面向对象中，多态的特征为：<strong>不同对象中同种行为的不同实现方式</strong>。在 Go 语言中可以使用<a href="https://gobyexample.com/interfaces" title="接口" target="_blank" rel="noopener">接口</a>实现这一特征。</p><p>我们先定义一个正方形 <code>Square</code> 和一个长方形 <code>Rectangle</code>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正方形</span></span><br><span class="line"><span class="keyword">type</span> Square <span class="keyword">struct</span> &#123;</span><br><span class="line">side <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">length, width <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们希望可以计算出这两个几何图形的面积。但由于他们的面积计算方式不同，我们需要定义两个不同的 <code>Area()</code> 方法。</p><p>于是，我们可以定义一个包含 <code>Area()</code> 方法的接口 <code>Shaper</code>，让 <code>Square</code> 和 <code>Rectangle</code> 都实现这个接口里的 <code>Area()</code>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口 Shaper</span></span><br><span class="line"><span class="keyword">type</span> Shaper <span class="keyword">interface</span> &#123;</span><br><span class="line">Area() <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算正方形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sq *Square)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> sq.side * sq.side</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算长方形的面积</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float32</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.length * r.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在 <code>main()</code> 函数中这样调用 <code>Area()</code>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := &amp;Rectangle&#123;<span class="number">10</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := &amp;Square&#123;<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Shaper 类型的数组</span></span><br><span class="line">shapes := []Shaper&#123;r, q&#125;</span><br><span class="line"><span class="comment">// 迭代数组上的每一个元素并调用 Area() 方法</span></span><br><span class="line"><span class="keyword">for</span> n, _ := <span class="keyword">range</span> shapes &#123;</span><br><span class="line">fmt.Println(<span class="string">"图形数据: "</span>, shapes[n])</span><br><span class="line">fmt.Println(<span class="string">"它的面积是: "</span>, shapes[n].Area())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">图形数据:  &amp;&#123;10 2&#125;</span></span><br><span class="line"><span class="comment">它的面积是:  20</span></span><br><span class="line"><span class="comment">图形数据:  &amp;&#123;10&#125;</span></span><br><span class="line"><span class="comment">它的面积是:  100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>由以上代码输出结果可知：<strong>不同对象调用 <code>Area()</code> 方法产生了不同的结果</strong>，展现了多态的特征。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>面向对象的三大特征是：封装、继承和多态</li><li>Go 语言使用<strong>结构体</strong>对属性进行封装，结构体就像是类的一种简化形式</li><li>在 Go 语言中，方法是作用在接收者（<em>receiver</em>）上的一个函数，接收者是某种类型的变量</li><li>名称首字母的大小写决定了该变量/常量/类型/接口/结构/函数……能否被外部包导入</li><li>无法被导入的字段可以使用 <code>getter</code> 和 <code>setter</code> 的方式来访问</li><li>Go 语言使用<strong>在结构体中内嵌匿名类型</strong>的方法来实现继承</li><li>使用接口可以实现多态</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Go 入门指南》: _<a href="https://github.com/unknwon/the-way-to-go_ZH_CN" target="_blank" rel="noopener">https://github.com/unknwon/the-way-to-go_ZH_CN</a>_</li></ul><hr><p><img src="/img/qrcode/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      面向对象三大特征以及在 Go 中的表现方式
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Go" scheme="http://jalan.space/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出：举个例子解读原码、反码与补码</title>
    <link href="http://jalan.space/2019/11/26/2019/binary-show/"/>
    <id>http://jalan.space/2019/11/26/2019/binary-show/</id>
    <published>2019-11-26T07:29:00.000Z</published>
    <updated>2019-11-26T14:15:41.470Z</updated>
    
    <content type="html"><![CDATA[<p>先来看一道 Go 语言中简单的运算题：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-128</span></span><br><span class="line">        <span class="keyword">var</span> b = a / <span class="number">-1</span></span><br><span class="line">        fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Go 语言中，<code>int8</code> 代表<strong>有符号</strong> 8 位整数。你觉得输出结果是什么呢？我们在文末再公布答案，在此之前，我们先来回顾一下有符号整数是什么。</p><h2 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h2><p>一个数在计算机中的<strong>二进制表示</strong>称为<strong>机器数</strong>，这个机器数是带符号的。它的最高位是符号位，0 代表正数，1 代表负数。</p><p>以 8 位有符号整数为例，<code>0000 0001</code> 代表十进制中的 1，<code>1000 0001</code> 则代表十进制中的 -1。</p><p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea804b49ccf4ba?w=768&amp;h=336&amp;f=png&amp;s=23988" alt=""></p><p>那么，你可能会问了：这样一来，8 位有符号整数的可表达范围应当是 [<code>1111 1111</code>, <code>0111 1111</code>]，即 [-127, 127]，但实际上它的可表达范围却是 [-128, 127]，那么 -128 又从何而来呢？</p><p>想要理解 -128 的来历，我们还要知道原码、反码和补码的概念。</p><h2 id="原码、反码和补码"><a href="#原码、反码和补码" class="headerlink" title="原码、反码和补码"></a>原码、反码和补码</h2><p>计算机需要使用特定的编码方式存储数据，原码、反码和补码都是一种特定的编码方式。以下示例均以 8 位二进制数举例。</p><h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p>原码是「未经更改的码」，指一个<strong>二进制数左边加上符号位</strong>后所得到的码。</p><ul><li>当二进制数大于 0 时，符号位为 0</li><li>当二进制数小于 0 时，符号位为 1</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea804b44bd180d?w=650&amp;h=372&amp;f=png&amp;s=13007" alt="-127 和 127 的原码表示"></p><p>因此，用这种编码方式表示有符号的 8 位二进制数，它的取值范围是 [<code>1111 1111</code>, <code>0111 1111</code>]，即 [-127, 127]。</p><p>如果我们使用原码计算 <code>(+1) + (-1)</code> 会得到什么结果呢？</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(+1) + (-1) = </span><br><span class="line"></span><br><span class="line">0000 0001（原码） </span><br><span class="line">+</span><br><span class="line">1000 0001（原码）</span><br><span class="line">=</span><br><span class="line">1000 0010（原码） </span><br><span class="line">=</span><br><span class="line">(-2)</span><br></pre></td></tr></table></figure><p>What? 等于 -2 了？这显然是错误的答案。</p><h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p>为了解决「正负数相加」的问题，人类又发明了<strong>反码</strong>。</p><p>反码的表示方式为：</p><ul><li>正数的反码等于它的原码</li><li>负数的反码则保留其原码符号位，然后对其他位进行取反操作</li></ul><blockquote><p>取反操作：将 0 变为 1，1 变为 0。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea804b4593fb28?w=885&amp;h=586&amp;f=png&amp;s=46240" alt="原码 -&gt; 反码"></p><p>此时，用反码来计算 <code>(+1) + (-1)</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(+1) + (-1) = </span><br><span class="line"></span><br><span class="line">0000 0001（反码） </span><br><span class="line">+</span><br><span class="line">1111 1110（反码） </span><br><span class="line">= </span><br><span class="line">1111 1111（反码） </span><br><span class="line">=</span><br><span class="line">(-0)</span><br></pre></td></tr></table></figure><p>我们知道，0 的原码是 <code>0000 0000</code> 或 <code>1000 0000</code>，0 的反码就是 <code>0000 0000</code> 或 <code>1111 1111</code>。即在反码中，<code>1111 1111</code> 象征 <code>-0</code>，我们终于求出了正确的结果。</p><h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>但反码的表示方法中存在着 <code>+0</code> 和 <code>-0</code> 两个零，我们希望只有一个 0，所以<strong>补码</strong>[^3]出现了。</p><p>补码的表示方式为：</p><ul><li>正数的补码是其本身</li><li>负数的补码是在它的反码基础上加 1</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/11/26/16ea804b4c51d596?w=899&amp;h=832&amp;f=png&amp;s=68376" alt="原码 -&gt; 反码 -&gt; 补码"></p><p>由于 <code>+1</code> 的操作，必将出现进位，<strong>如果进位超过长度限制，最高位就会丢失</strong>。</p><p>会发生最高位丢失的数就是 <code>-0</code> 的反码表示 <code>1111 1111</code>，它的补码为 <code>1 0000 0000</code>。由于长度是 8 位，最高位的 1 已经溢出，所以丢弃，<code>-0</code> 的补码就成了 <code>0000 0000</code>，和刚才我们所提到的 <code>+0</code> 完美重合了！</p><p>用补码来计算 <code>(+1) + (-1)</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(+1) + (-1) = </span><br><span class="line"></span><br><span class="line">0000 0001（补码） </span><br><span class="line">+</span><br><span class="line">1111 1111（补码） </span><br><span class="line">= </span><br><span class="line">0000 0000（补码） </span><br><span class="line">=</span><br><span class="line">(0)</span><br></pre></td></tr></table></figure><p>答案正确！</p><p><strong>因此，计算机内部使用补码方式表示负数，因为它让「正数 + 负数」也能使用同一套加法规则，使得所有的加法运算可以使用同一种电路完成。</strong></p><h2 id="128-的由来"><a href="#128-的由来" class="headerlink" title="-128 的由来"></a>-128 的由来</h2><p>上面我们说到如果用补码的方式进行表示，<code>-0</code> 就不存在了，为了让有限的位数尽可能表示更多的数，省下的 <code>1000 0000</code> 就用来表示 <code>-128</code> 了。</p><p>让我们用补码来计算一下 <code>(-1) + (-127)</code>：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(-1) + (-127) = </span><br><span class="line"></span><br><span class="line">1000 0001（原码）+</span><br><span class="line">1111 1111（原码）</span><br><span class="line">=</span><br><span class="line">1111 1110（反码）+</span><br><span class="line">1000 0000（反码）</span><br><span class="line">=</span><br><span class="line">1111 1111（补码）+</span><br><span class="line">1000 0001（补码） </span><br><span class="line">=</span><br><span class="line">1 1000 0000（补码）</span><br><span class="line">=</span><br><span class="line">1000 0000（丢弃最高位）</span><br><span class="line">= </span><br><span class="line">(-128)</span><br></pre></td></tr></table></figure><p><code>(-1) + (-127)</code> 的结果正是 -128。但由于 <code>1000 0000</code> 是 <code>-0</code> 的补码，所以 <code>-128</code> 没有与之对应的原码和反码表示。</p><h2 id="公布答案"><a href="#公布答案" class="headerlink" title="公布答案"></a>公布答案</h2><p>好了，让我们再回头看一下开头的那段代码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> a <span class="keyword">int8</span> = <span class="number">-128</span></span><br><span class="line">        <span class="keyword">var</span> b = a / <span class="number">-1</span></span><br><span class="line">        fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见了：<code>int8</code> 的可表示范围是 <code>[-128, 127]</code>，所以可以被赋值为 -128。而 <code>(-128) / (-1) = 128</code> 显然超过了该表示范围，+128 用有符号整数表示需要 9 位，表示为 <code>0 1000 0000</code>，最高位的 0 已经溢出，所以丢弃，导致结果是 <code>1000 0000</code>，即 -128。</p><p>所以这段代码的输出结果就是 -128 啦~</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>int8</code> 表示有符号 8 位整数，它的可表示范围是 <code>[-128, 127]</code></li><li>计算机内部使用补码方式表示负数</li><li>补码解决了 <code>+0</code> 和 <code>-0</code> 并存的问题，并省下 <code>-0</code> 的表示方法，多表示了一个最低数 -128</li><li>补码使得所有整数集都能使用同一套加法规则</li><li>如果发生溢出，多出的高位将被截取</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E7%A0%81" target="_blank" rel="noopener">维基百科-原码</a></li><li><a href="https://zh.wikipedia.org/zh-hans/%E5%8F%8D%E7%A0%81" target="_blank" rel="noopener">维基百科-反码</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%8D%E7%A0%81" target="_blank" rel="noopener">维基百科-补码</a> </li></ul><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/5_ly1EqGShhLKsNHr8fzwA" target="_blank" rel="noopener">聊聊 Go 语言中的字符表示与字符串遍历</a></li><li><a href="https://mp.weixin.qq.com/s/wAjlIFZ3d9rnTU2QGyxniw" target="_blank" rel="noopener">认识 Go 语言中的数组</a></li></ul><hr><p><img src="/img/qrcode/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      计算机中为什么使用补码表示负数呢？
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Go" scheme="http://jalan.space/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>认识 Go 语言中的数组</title>
    <link href="http://jalan.space/2019/11/21/2019/go-array/"/>
    <id>http://jalan.space/2019/11/21/2019/go-array/</id>
    <published>2019-11-21T12:59:00.000Z</published>
    <updated>2019-11-21T13:22:56.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数组是具有<strong>相同唯一类型</strong>的一组<strong>已编号</strong>且<strong>长度固定</strong>的数据项序列。</p></blockquote><h2 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h2><p>在 Go 语言中，数组的声明方式为 <code>var identifier [len]type</code>。</p><p>声明时没有指定数组的初始化值，因此所有的元素都会被<strong>自动初始化为默认值 0</strong>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">var</span> a1 [<span class="number">5</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>Go 语言中的数组是值类型，因此还可以用 <code>new</code> 来创建：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a2 = <span class="built_in">new</span>([<span class="number">5</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure><p><code>new</code> 返回类型的指针，因此 <code>a1</code> 与 <code>a2</code> 的区别在于：<code>a1</code> 的类型为 <code>[5]int</code>，<code>a2</code> 的类型为 <code>*[5]int</code>。</p><h2 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h2><p>我们通过在 <code>{}</code> 中填写初始化值来初始化数组。</p><h3 id="指明数组长度"><a href="#指明数组长度" class="headerlink" title="指明数组长度"></a>指明数组长度</h3><p>指明数组的长度 <code>len</code>，然后在 <code>{}</code> 中填写初始化值，这些值会按下标从小到大的顺序分配。</p><p>初始化值的个数不允许超过长度 <code>len</code>。当初始化值的个数小于 <code>len</code> 时，未被初始化的位置等于默认值 0。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组长度为 5，初始化了前两个数，未初始化的位是 0</span></span><br><span class="line">b := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125; </span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> b &#123;</span><br><span class="line">fmt.Printf(<span class="string">"下标 = %d, 值 = %d\n"</span>, index, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">下标 = 0, 值 = 1</span></span><br><span class="line"><span class="comment">下标 = 1, 值 = 2</span></span><br><span class="line"><span class="comment">下标 = 2, 值 = 0</span></span><br><span class="line"><span class="comment">下标 = 3, 值 = 0</span></span><br><span class="line"><span class="comment">下标 = 4, 值 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>也可以使用 <code>{index1: a, index2: b}</code> 的方式初始化数组，指明数组的索引和对应的下标值，未指明的下标所在位置的值等于默认值 0：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过数组索引初始化</span></span><br><span class="line"><span class="comment">// d[0] = 1, d[2] = 3，其他位置等于 0</span></span><br><span class="line">d := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>: <span class="number">1</span>, <span class="number">2</span>: <span class="number">3</span>&#125; </span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> d &#123;</span><br><span class="line">fmt.Printf(<span class="string">"下标 = %d, 值 = %d\n"</span>, index, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">下标 = 0, 值 = 1</span></span><br><span class="line"><span class="comment">下标 = 1, 值 = 0</span></span><br><span class="line"><span class="comment">下标 = 2, 值 = 3</span></span><br><span class="line"><span class="comment">下标 = 3, 值 = 0</span></span><br><span class="line"><span class="comment">下标 = 4, 值 = 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="暗示数组长度"><a href="#暗示数组长度" class="headerlink" title="暗示数组长度"></a>暗示数组长度</h3><p>初始化时你也可以不直接指明数组的长度，而是使用 <code>[...]</code> 代替。和指明数组长度时相同，此时也可以使用顺序填写和指定索引两种方式来初始化数组。</p><p>当使用 <code>{a, b, c}</code> 方式传递初始化值时，Go 语言将<strong>通过初始化元素的个数来确定数组的长度</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过传递初始化值确定数组长度</span></span><br><span class="line"><span class="comment">// 传递了 5 个元素，数组长度为 5</span></span><br><span class="line">c := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> index, val := <span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Printf(<span class="string">"下标 = %d, 值 = %d\n"</span>, index, val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">下标 = 0, 值 = 1</span></span><br><span class="line"><span class="comment">下标 = 1, 值 = 2</span></span><br><span class="line"><span class="comment">下标 = 2, 值 = 3</span></span><br><span class="line"><span class="comment">下标 = 3, 值 = 4</span></span><br><span class="line"><span class="comment">下标 = 4, 值 = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>若通过指明数组的索引和对应的值来初始化数组，此时数组的长度就等于 <code>最大索引数 + 1</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 最大索引是 9，所以数组的长度为 10</span><br><span class="line">e := [...]int&#123;9: 10&#125; </span><br><span class="line">for index, val := range e &#123;</span><br><span class="line">fmt.Printf(&quot;下标 = %d, 值 = %d\n&quot;, index, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Output:</span><br><span class="line">下标 = 0, 值 = 0</span><br><span class="line">下标 = 1, 值 = 0</span><br><span class="line">下标 = 2, 值 = 0</span><br><span class="line">下标 = 3, 值 = 0</span><br><span class="line">下标 = 4, 值 = 0</span><br><span class="line">下标 = 5, 值 = 0</span><br><span class="line">下标 = 6, 值 = 0</span><br><span class="line">下标 = 7, 值 = 0</span><br><span class="line">下标 = 8, 值 = 0</span><br><span class="line">下标 = 9, 值 = 10</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2><p>在 Go 语言中使用 <code>for ... range</code> 遍历数组：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// i 是数组索引</span></span><br><span class="line"><span class="keyword">for</span> i, _ := <span class="keyword">range</span> arr1 &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组是值类型"><a href="#数组是值类型" class="headerlink" title="数组是值类型"></a>数组是值类型</h2><p>和 C/C++ 不同，Go 语言的数组是<strong>值类型</strong>的。这样一来，<strong>赋值和传参都会复制整个数组，而不是指针</strong>。</p><p>我们初始化一个数组 <code>a</code>，并把它赋值给数组 <code>b</code>，然后打印两者的值与指针：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a := [5]int&#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">b := a</span><br><span class="line">fmt.Printf(&quot;数组 a - 值：%v，指针：%p\n&quot;, a, &amp;a)</span><br><span class="line">fmt.Printf(&quot;数组 b - 值：%v，指针：%p\n&quot;, b, &amp;b)</span><br><span class="line">/* Output:</span><br><span class="line">数组 a - 值：[1 2 3 4 5]，指针：0xc00001e0f0</span><br><span class="line">数组 b - 值：[1 2 3 4 5]，指针：0xc00001e120</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>可以看到，两者的值是相同的，但是内存地址却不同，说明<strong>在赋值的过程中复制了整个数组</strong>。</p><p>我们再来看一下传参的例子。</p><p>定义一个函数 <code>transmitA</code>，把刚才我们初始化的数组 <code>a</code> 传入：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"数组 a - 值：%v，指针：%p\n"</span>, a, &amp;a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组 a 传入函数</span></span><br><span class="line">transmitA(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">transmitA</span><span class="params">(a [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"传入函数的数组 a - 值：%v，指针：%p\n"</span>, a, &amp;a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">数组 a - 值：[1 2 3 4 5]，指针：0xc00001e0f0</span></span><br><span class="line"><span class="comment">传入函数的数组 a - 值：[1 2 3 4 5]，指针：0xc00001e150</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从输出可以看出，两者的值依然相同，内存地址却是不同的。这说明<strong>在传参时数组也被复制了</strong>。</p><h2 id="数组指针与指针数组"><a href="#数组指针与指针数组" class="headerlink" title="数组指针与指针数组"></a>数组指针与指针数组</h2><p>数组指针与指针数组听起来似乎有点拗口，那么来展开说明一下：</p><ul><li>数组指针：（指向）数组（的）指针</li><li>指针数组：（装满了）指针（的）数组</li></ul><p>也就是说，<strong>数组指针是个指针，它指向一个数组；而指针数组是个数组，它里面装满了指针</strong>。</p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>声明一个数组 <code>a</code>，然后将它的地址赋值给 <code>arrayPointer</code>。这样一来，<code>arrayPointer</code> 就是一个指向数组 <code>a</code> 的指针，即数组指针，它的类型为 <code>*[5]int</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// 把数组 a 的地址赋值给 arrayPointer</span></span><br><span class="line"><span class="comment">// arrayPointer 是指向数组的指针，类型为 *[5]int</span></span><br><span class="line">arrayPointer := &amp;a</span><br><span class="line">fmt.Println(arrayPointer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">&amp;[1 2 3 4 5]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>初始化数组 <code>pointerArray</code>，传入的初始化值为整型 <code>m</code> 与 <code>n</code> 的内存地址（<code>&amp;m</code> 和 <code>&amp;n</code>），那么 <code>pointerArray</code> 就是一个装着 <code>int</code> 类型指针的数组，即指针数组，它的类型为 <code>[2]*int</code>。</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">m := <span class="number">1</span></span><br><span class="line">n := <span class="number">2</span></span><br><span class="line"><span class="comment">// 初始化 pointerArray，传入 m 与 n 的地址</span></span><br><span class="line"><span class="comment">// pointerArray 包含了整型地址，是一个装着指针的数组</span></span><br><span class="line">pointerArray := [<span class="number">2</span>]*<span class="keyword">int</span>&#123;&amp;m, &amp;n&#125;</span><br><span class="line">fmt.Println(pointerArray)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0xc0000aa000 0xc0000aa008]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>数组的长度是固定的，初始化时需要「明示」或「暗示」数组的长度</li><li><strong>数组的长度是数组类型的组成部分</strong>，<code>[2]int</code> 与 <code>[100]int</code> 是不同类型的数组</li><li>使用 <code>for ... range</code> 遍历数组</li><li>在 Go 语言中，数组是<strong>值类型</strong>，赋值和传递参数都会发生数组的复制</li><li>数组指针是一个指针，它指向了一个数组</li><li>指针数组是一个数组，它里面装着指针</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/qyuhen/book" target="_blank" rel="noopener">《Go 学习笔记》</a></li></ul><hr><p><img src="/img/qrcode/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      聊聊 Go 语言中的数组类型
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Go" scheme="http://jalan.space/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>聊聊 Go 语言中的字符表示与字符串遍历</title>
    <link href="http://jalan.space/2019/11/16/2019/go-character-string-range/"/>
    <id>http://jalan.space/2019/11/16/2019/go-character-string-range/</id>
    <published>2019-11-16T15:57:00.000Z</published>
    <updated>2019-11-21T13:29:18.484Z</updated>
    
    <content type="html"><![CDATA[<p>和其他语言不同，在 Go 语言中没有字符类型，<strong>字符只是整数的特殊用例</strong>。</p><p>为什么说<strong>字符只是整数的特殊用例</strong>呢？因为在 Go 中，用于表示字符的 <code>byte</code> 和 <code>rune</code> 类型都是<strong>整型的别名</strong>。在 Go 的源码中我们可以看到：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish byte values from 8-bit unsigned</span></span><br><span class="line"><span class="comment">// integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rune is an alias for int32 and is equivalent to int32 in all ways. It is</span></span><br><span class="line"><span class="comment">// used, by convention, to distinguish character values from integer values.</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br></pre></td></tr></table></figure><ul><li><code>byte</code> 是 <code>uint8</code> 的别名，长度为 1 个字节，用于表示 ASCII 字符</li><li><code>rune</code> 是 <code>int32</code> 的别名，长度为 4 个字节，用于表示以 UTF-8 编码的 Unicode 码点</li></ul><blockquote><p>Tips：Unicode 从 0 开始，为每个符号指定一个编号，这叫做「码点」（code point）。</p></blockquote><h2 id="字符的表示"><a href="#字符的表示" class="headerlink" title="字符的表示"></a>字符的表示</h2><p>那么，如何在 Go 语言中表示字符呢？</p><p>在 Go 语言中使用<strong>单引号包围</strong>来表示字符，例如 <code>&#39;j&#39;</code>。</p><h3 id="byte"><a href="#byte" class="headerlink" title="byte"></a>byte</h3><p>如果要表示 <code>byte</code> 类型的字符，可以使用 <code>byte</code> 关键字来指明字符变量的类型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> byteC <span class="keyword">byte</span> = <span class="string">'j'</span></span><br></pre></td></tr></table></figure><p>又因为 <code>byte</code> 实质上是整型 <code>uint8</code>，所以可以直接转成整型值。在格式化说明符中我们使用 <code>%c</code> 表示字符，<code>%d</code> 表示整型：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明 byte 类型字符</span></span><br><span class="line"><span class="keyword">var</span> byteC <span class="keyword">byte</span> = <span class="string">'j'</span></span><br><span class="line">fmt.Printf(<span class="string">"字符 %c 对应的整型为 %d\n"</span>, byteC, byteC)</span><br><span class="line"><span class="comment">// Output: 字符 j 对应的整型为 106</span></span><br></pre></td></tr></table></figure><h3 id="rune"><a href="#rune" class="headerlink" title="rune"></a>rune</h3><p>与 <code>byte</code> 相同，想要声明 <code>rune</code> 类型的字符可以使用 <code>rune</code> 关键字指明：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> runeC <span class="keyword">rune</span> = <span class="string">'J'</span></span><br></pre></td></tr></table></figure><p><strong>但如果在声明一个字符变量时没有指明类型，Go 会默认它是 <code>rune</code> 类型</strong>：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">runeC := <span class="string">'J'</span></span><br><span class="line">fmt.Printf(<span class="string">"字符 %c 的类型为 %T\n"</span>, runeC, runeC)</span><br><span class="line"><span class="comment">// Output: 字符 J 的类型为 int32</span></span><br></pre></td></tr></table></figure><h2 id="为什么需要两种类型？"><a href="#为什么需要两种类型？" class="headerlink" title="为什么需要两种类型？"></a>为什么需要两种类型？</h2><p>看到这里你可能会问了，既然都用于表示字符，为什么还需要两种类型呢？</p><p>我们知道，<code>byte</code> 占用一个字节，因此它可以用于表示 ASCII 字符。<strong>而 UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等</strong>。<code>byte</code> 显然不擅长这样的表示，就算你想要使用多个 <code>byte</code> 进行表示，你也无从知晓你要处理的 UTF-8 字符究竟占了几个字节。</p><p>因此，如果你在中文字符串上狂妄地进行截取，一定会输出乱码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testString := <span class="string">"你好，世界"</span></span><br><span class="line">fmt.Println(testString[:<span class="number">2</span>]) <span class="comment">// 输出乱码，因为截取了前两个字节</span></span><br><span class="line">fmt.Println(testString[:<span class="number">3</span>]) <span class="comment">// 输出「你」，一个中文字符由三个字节表示</span></span><br></pre></td></tr></table></figure><p>此时就需要 <code>rune</code> 的帮助了。利用 <code>[]rune()</code> 将字符串转为 Unicode 码点再进行截取，这样就无需考虑字符串中含有 UTF-8 字符的情况了：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testString := <span class="string">"你好，世界"</span></span><br><span class="line">fmt.Println(<span class="keyword">string</span>([]<span class="keyword">rune</span>(testString)[:<span class="number">2</span>])) <span class="comment">// 输出：「你好」</span></span><br></pre></td></tr></table></figure><blockquote><p>Tips：Unicode 和 ASCII 一样，是一种字符集，UTF-8 则是一种编码方式。</p></blockquote><h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><p>字符串遍历有两种方式，一种是下标遍历，一种是使用 <code>range</code>。</p><h3 id="下标遍历"><a href="#下标遍历" class="headerlink" title="下标遍历"></a>下标遍历</h3><p>由于在 Go 语言中，字符串以 UTF-8 编码方式存储，使用 <code>len()</code> 函数获取字符串长度时，获取到的是该 UTF-8 编码字符串的字节长度，<strong>通过下标索引字符串将会产生一个字节</strong>。因此，如果字符串中含有 UTF-8 编码字符，就会出现乱码：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testString := <span class="string">"Hello，世界"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(testString); i++ &#123;</span><br><span class="line">c := testString[i]</span><br><span class="line">fmt.Printf(<span class="string">"%c 的类型是 %s\n"</span>, c, reflect.TypeOf(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">H 的类型是 uint8（ASCII 字符返回正常）</span></span><br><span class="line"><span class="comment">e 的类型是 uint8</span></span><br><span class="line"><span class="comment">l 的类型是 uint8</span></span><br><span class="line"><span class="comment">l 的类型是 uint8</span></span><br><span class="line"><span class="comment">o 的类型是 uint8</span></span><br><span class="line"><span class="comment">ï 的类型是 uint8（从这里开始出现了奇怪的乱码）</span></span><br><span class="line"><span class="comment">¼ 的类型是 uint8</span></span><br><span class="line"><span class="comment"> 的类型是 uint8</span></span><br><span class="line"><span class="comment">ä 的类型是 uint8</span></span><br><span class="line"><span class="comment">¸ 的类型是 uint8</span></span><br><span class="line"><span class="comment"> 的类型是 uint8</span></span><br><span class="line"><span class="comment">ç 的类型是 uint8</span></span><br><span class="line"><span class="comment"> 的类型是 uint8</span></span><br><span class="line"><span class="comment"> 的类型是 uint8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p><code>range</code> 遍历则会得到 <code>rune</code> 类型的字符：</p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">testString := <span class="string">"Hello，世界"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, c := <span class="keyword">range</span> testString &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%c 的类型是 %s\n"</span>, c, reflect.TypeOf(c))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">H 的类型是 int32</span></span><br><span class="line"><span class="comment">e 的类型是 int32</span></span><br><span class="line"><span class="comment">l 的类型是 int32</span></span><br><span class="line"><span class="comment">l 的类型是 int32</span></span><br><span class="line"><span class="comment">o 的类型是 int32</span></span><br><span class="line"><span class="comment">， 的类型是 int32</span></span><br><span class="line"><span class="comment">世 的类型是 int32</span></span><br><span class="line"><span class="comment">界 的类型是 int32</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Go 语言中没有字符的概念，<strong>一个字符就是一堆字节</strong>，它可能是单个字节（ASCII 字符集），也有可能是多个字节（Unicode 字符集）</li><li><code>byte</code> 是 <code>uint8</code> 的别名，长度为 1 个字节，用于表示 ASCII 字符</li><li><code>rune</code> 则是 <code>int32</code> 的别名，长度为 4 个字节，用于表示以 UTF-8 编码的 Unicode 码点</li><li>字符串的截取是以字节为单位的</li><li>使用下标索引字符串会产生字节</li><li>想要遍历 <code>rune</code> 类型的字符则使用 <code>range</code> 方法进行遍历</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">阮一峰: Unicode 与 JavaScript 详解</a></li><li><a href="https://blog.golang.org/strings" target="_blank" rel="noopener">The Go Blog - Strings, bytes, runes and characters in Go</a></li></ul><p><img src="/img/qrcode/wechat.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      实时同步其他远程仓库
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="Go" scheme="http://jalan.space/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>在 Laravel 生产环境中填充数据</title>
    <link href="http://jalan.space/2019/10/27/2019/php-laravel-production-seed/"/>
    <id>http://jalan.space/2019/10/27/2019/php-laravel-production-seed/</id>
    <published>2019-10-27T13:32:00.000Z</published>
    <updated>2019-11-21T13:26:26.604Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Seeder is mainly to be used with test data。</p></blockquote><p>在 Laravel 中，我们常用 <a href="https://laravel.com/docs/5.8/seeding" target="_blank" rel="noopener">Database: Seeding</a> 操作填充测试数据，但在正式环境中使用 Seed 并不安全。</p><p>因为在测试环境中，无论运行多少次 <code>php artisan db:seed</code> 都无任何数据丢失的风险，而在正式环境中，这个操作<strong>一旦被执行就会被遗忘</strong>。所以，在生产环境中，我们选择使用<strong>迁移文件</strong>替代 Seed。</p><p>在迁移文件中，使用 <code>DB::table($tableName)-&gt;insert()</code> 方法来写入数据：</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestTable</span> <span class="keyword">extends</span> <span class="title">Migration</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $tableName = <span class="string">'tests'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">up</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DB::table(<span class="keyword">$this</span>-&gt;tableName)-&gt;insert([</span><br><span class="line">            [</span><br><span class="line">                <span class="string">'test'</span> =&gt; <span class="number">1</span>,</span><br><span class="line">            ],</span><br><span class="line">            [</span><br><span class="line">                <span class="string">'test'</span> =&gt; <span class="number">2</span>,</span><br><span class="line">            ],</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reverse the migrations.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，一旦执行迁移文件，这次数据写入就会被记录到迁移记录中，防止下次重复执行。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://stackoverflow.com/questions/21580088/laravel-migrations-seeding-for-production-data" target="_blank" rel="noopener">Laravel : Migrations &amp; Seeding for production data</a></li><li><a href="https://learnku.com/laravel/t/26049" target="_blank" rel="noopener">Laravel 数据填充（Seed）6 个小技巧分享</a></li></ul>]]></content>
    
    <summary type="html">
    
      Seed Or Migrate？
    
    </summary>
    
      <category term="Web屠龙刀" scheme="http://jalan.space/categories/Web%E5%B1%A0%E9%BE%99%E5%88%80/"/>
    
    
      <category term="PHP" scheme="http://jalan.space/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://jalan.space/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>二零一九碎碎念</title>
    <link href="http://jalan.space/2019/10/23/2019/bibi/"/>
    <id>http://jalan.space/2019/10/23/2019/bibi/</id>
    <published>2019-10-23T13:41:00.000Z</published>
    <updated>2019-10-23T15:33:29.931Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="薯条是？" />    <label for="pass">薯条是？</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      我与春风皆过客
    
    </summary>
    
      <category term="少年人的冲动" scheme="http://jalan.space/categories/%E5%B0%91%E5%B9%B4%E4%BA%BA%E7%9A%84%E5%86%B2%E5%8A%A8/"/>
    
    
      <category term="生活啊" scheme="http://jalan.space/tags/%E7%94%9F%E6%B4%BB%E5%95%8A/"/>
    
  </entry>
  
</feed>

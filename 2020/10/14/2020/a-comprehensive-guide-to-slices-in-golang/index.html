<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="江佳扬 | 死宅 | PHP | Python | Golang | 算法与数据结构 | 服务端 | 技术博客"><title>【译】Golang 切片综合指南 | 忘归</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + 'c47c7dbbbbb8b1bd7729048f358cd896';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">【译】Golang 切片综合指南</h1><a id="logo" href="/.">忘归</a><p class="description">愿得朱衣暗点头。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/cat/"><i class="fa fa-heart"> 喵</i></a><a href="http://www.jalan.space:8081"><i class="fa fa-book"> 时光</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">【译】Golang 切片综合指南</h1><div class="post-meta">Oct 14, 2020<span> | </span><span class="category"><a href="/categories/技多不压身/">技多不压身</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> 分钟</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/" href="/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Golang-切片综合指南"><span class="toc-number">1.</span> <span class="toc-text">Golang 切片综合指南</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#切片的表示"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">切片的表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用长度声明一个切片"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">使用长度声明一个切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用长度和容量声明一个切片"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">使用长度和容量声明一个切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用切片字面量创建切片"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">使用切片字面量创建切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明一个带有索引位置的切片"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">声明一个带有索引位置的切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明数组与切片的区别"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">声明数组与切片的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明一个-nil-切片"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">声明一个 nil 切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#声明一个空切片"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">声明一个空切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为任何特定索引赋值"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">为任何特定索引赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对切片进行切片"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">对切片进行切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片的长度与容量如何计算？"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">切片的长度与容量如何计算？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对一个切片进行更改的结果"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">对一个切片进行更改的结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时错误显示索引超出范围"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">运行时错误显示索引超出范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片增长"><span class="toc-number">1.0.0.14.</span> <span class="toc-text">切片增长</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-append-向切片追加元素"><span class="toc-number">1.0.0.15.</span> <span class="toc-text">使用 append 向切片追加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用-append-增加切片的长度和容量"><span class="toc-number">1.0.0.16.</span> <span class="toc-text">使用 append 增加切片的长度和容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#将一个切片追加到另一个切片中"><span class="toc-number">1.0.0.17.</span> <span class="toc-text">将一个切片追加到另一个切片中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对切片执行索引"><span class="toc-number">1.0.0.18.</span> <span class="toc-text">对切片执行索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历切片"><span class="toc-number">1.0.0.19.</span> <span class="toc-text">遍历切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">1.0.0.20.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="post-content"><blockquote>
<ul>
<li>原文地址：<a href="https://codeburst.io/a-comprehensive-guide-to-slices-in-golang-bacebfe46669" target="_blank" rel="noopener">A Comprehensive Guide to Slices in Golang</a></li>
<li>原文作者：<a href="https://medium.com/@rksurwase" target="_blank" rel="noopener">Radhakishan Surwase</a></li>
<li>译文出自：<a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a></li>
<li>本文永久链接：<a href="https://github.com/xitu/gold-miner/blob/master/article/2020/a-comprehensive-guide-to-slices-in-golang.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/article/2020/a-comprehensive-guide-to-slices-in-golang.md</a></li>
<li>译者：<a href="http://jalan.space/">JalanJiang</a></li>
<li>校对者：<a href="https://github.com/Eminlin" target="_blank" rel="noopener">Emin</a>，<a href="https://github.com/suhanyujie" target="_blank" rel="noopener">Samuel Jie</a></li>
</ul>
</blockquote>
<h1 id="Golang-切片综合指南"><a href="#Golang-切片综合指南" class="headerlink" title="Golang 切片综合指南"></a>Golang 切片综合指南</h1><p><img src="https://cdn-images-1.medium.com/max/12000/1*i7lsjZyVnJxDEIg8Qibdlw.jpeg" alt="由于 [Paweł Czerwiński](https://unsplash.com/@pawel_czerwinski) 拍摄于 [Unsplash](https://unsplash.com/s/photos/array)"></p>
<p>在这篇文章中，我们将复习「切片」的概念，它是 Golang 中一个重要的数据结构，这一数据结构为你提供了处理与管理数据集合的方法。切片是围绕着动态数组的概念构建的，它与动态数组相似，可以根据你的需要而伸缩。</p>
<ul>
<li>就增长而言，切片是<strong>动态</strong>的，因为它们有自己的内置函数 <strong>append</strong>，可以快速高效地增长切片。</li>
<li>你还可以通过切割底层内存来减少切片的大小。</li>
<li>在底层内存中切片是在连续的块上分配的，因此切片为你提供的便利之处包括：索引、迭代与垃圾回收优化。</li>
</ul>
<h4 id="切片的表示"><a href="#切片的表示" class="headerlink" title="切片的表示"></a>切片的表示</h4><ul>
<li>切片不存储任何数据，它仅描述底层数组的一部分。</li>
<li>切片使用一个包含三个字段的结构表示：指向底层数组的指针（pointer）、长度（length）与容量（capacity）。</li>
<li>这个数据结构类似于切片的描述符。</li>
</ul>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*PW4Y8P0_gTspgYwcxfDrtQ.png" alt="图 1：切片的表示"></p>
<ul>
<li><strong>指针（Pointer）：</strong>指针用于指向数组的第一个元素，这个元素可以通过切片进行访问。在这里，指向的元素不必是数组的第一个元素。</li>
<li><strong>长度（Length）：</strong>长度代表数组中所有元素的总数。</li>
<li><strong>容量（Capacity）：</strong>容量表示切片可扩展的最大大小。 </li>
</ul>
<h4 id="使用长度声明一个切片"><a href="#使用长度声明一个切片" class="headerlink" title="使用长度声明一个切片"></a>使用长度声明一个切片</h4><p>在声明切片过程中，当你仅指定长度（Length）时，容量（Capacity）值与长度（Length）值相同。</p>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*5ssbGNTliiFWF_rcxN6RRg.png" alt="图 2：使用长度声明一个切片。"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用长度声明一个切片。创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br></pre></td></tr></table></figure>
<h4 id="使用长度和容量声明一个切片"><a href="#使用长度和容量声明一个切片" class="headerlink" title="使用长度和容量声明一个切片"></a>使用长度和容量声明一个切片</h4><p>在声明切片过程中，当你分别指定长度（Length）和容量（Capacity）时，这将初始化一段无法访问的底层数组来创建一个具有可用容量的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 使用长度和容量声明一个切片</span></span><br><span class="line"><span class="comment"> 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度为 3，容量为 5 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*6OLPqO2Z2x-QKPU_9EDA2A.png" alt="图 3：使用长度和容量声明一个切片。"></p>
<p>但请注意，尝试创建容量小于长度的切片是不允许的。</p>
<h4 id="使用切片字面量创建切片"><a href="#使用切片字面量创建切片" class="headerlink" title="使用切片字面量创建切片"></a>使用切片字面量创建切片</h4><p>创建<strong>切片</strong>的惯用方法是使用<strong>切片字面量</strong>。它与创建数组相似，只是它不需要在 [ ] 操作符中指定值。你初始化切片时所用元素的数量将决定切片的初始长度与容量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串类型切片。</span></span><br><span class="line"><span class="comment">// 长度与容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">string</span>&#123;<span class="string">"Red"</span>, <span class="string">"Blue"</span>, <span class="string">"Green"</span>, <span class="string">"Yellow"</span>, <span class="string">"Pink"</span>&#125; </span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印结果 5</span></span><br><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度与容量均为 3。</span></span><br><span class="line">intSlice:= []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(intSlice)) <span class="comment">// 打印结果 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(intSlice)) <span class="comment">// 打印结果 3</span></span><br></pre></td></tr></table></figure>
<h4 id="声明一个带有索引位置的切片"><a href="#声明一个带有索引位置的切片" class="headerlink" title="声明一个带有索引位置的切片"></a>声明一个带有索引位置的切片</h4><p>当使用切片<strong>字面量</strong>时，你可以初始化切片的<strong>长度</strong>与<strong>容量</strong>。你所需要做的就是初始化表示所需长度和容量的<strong>索引</strong>。下面的语法将创建一个长度和容量均为 100 的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建字符串类型切片。</span></span><br><span class="line"><span class="comment">// 用空字符串初始化第 100 个元素。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">99</span>: <span class="number">88</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) </span><br><span class="line"><span class="comment">// 打印结果 100</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) </span><br><span class="line"><span class="comment">// 打印结果 100</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*nG722TP5WDx3hZOHBpcFyQ.png" alt="图 4: 声明一个带有索引位置的切片。"></p>
<h4 id="声明数组与切片的区别"><a href="#声明数组与切片的区别" class="headerlink" title="声明数组与切片的区别"></a>声明数组与切片的区别</h4><ul>
<li>如果你使用 [ ] 操作符中指定一个值，那么你在创建一个数组。</li>
<li>如果你不在 [ ] 中指定值，则创建一个切片。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个包含 3 个整数的数组。</span></span><br><span class="line">array := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度和容量均为 3 的整型切片。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明一个-nil-切片"><a href="#声明一个-nil-切片" class="headerlink" title="声明一个 nil 切片"></a>声明一个 nil 切片</h4><ul>
<li>切片用 <code>nil</code> 代表零值。</li>
<li>一个 nil 切片的长度和容量等于 0，且没有底层数组。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型 nil 切片。</span></span><br><span class="line"><span class="keyword">var</span> slice []<span class="keyword">int32</span></span><br><span class="line">fmt.Println(slice == <span class="literal">nil</span>) </span><br><span class="line"><span class="comment">// 此行将打印 true</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice))   </span><br><span class="line"><span class="comment">// 此行将打印 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice))</span><br><span class="line"><span class="comment">// 此行将打印 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*2KWa4gM4_M_47eBcKISK9w.png" alt="图 5：声明 nil 切片。"></p>
<h4 id="声明一个空切片"><a href="#声明一个空切片" class="headerlink" title="声明一个空切片"></a>声明一个空切片</h4><p>还可以通过初始化声明切片创建一个空切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 make 来创建一个整型空切片。</span></span><br><span class="line">sliceOne := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment">// 使用切片字面量创建一个整型空切片。</span></span><br><span class="line">sliceTwo := []<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">fmt.Println(sliceOne == <span class="literal">nil</span>) <span class="comment">// 这将打印 false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sliceOne))   <span class="comment">// 这将打印 0 </span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(sliceOne))   <span class="comment">// 这将打印 0</span></span><br><span class="line">fmt.Println(sliceTwo == <span class="literal">nil</span>) <span class="comment">// 这将打印 false</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(sliceTwo))   <span class="comment">// 这将打印 0</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(sliceTwo))   <span class="comment">// 这将打印 0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*x3dfcqD71X5M0G2F4D7QoQ.png" alt="图 6：声明一个空切片。"></p>
<h4 id="为任何特定索引赋值"><a href="#为任何特定索引赋值" class="headerlink" title="为任何特定索引赋值"></a>为任何特定索引赋值</h4><p>要修改单个元素的值，请使用 [ ] 操作符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 包含 4 个元素的长度和容量。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">fmt.Println(slice) <span class="comment">// 这将打印 [10 20 30 40]</span></span><br><span class="line">slice[<span class="number">1</span>] = <span class="number">25</span> <span class="comment">// 改变索引 1 的值。</span></span><br><span class="line">fmt.Println(slice) <span class="comment">// 这将打印 [10 25 30 40]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*E-LTi2XYMjW0m5RGwzfktQ.png" alt="图 7：为任何特定索引赋值。"></p>
<h4 id="对切片进行切片"><a href="#对切片进行切片" class="headerlink" title="对切片进行切片"></a>对切片进行切片</h4><p>我们之所以称呼切片为切片，是因为你可以通过对底层数组的一部分进行切片来创建一个新的切片。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个整型切片。</span></span><br><span class="line"><span class="comment">长度和容量均为 5。*/</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line">fmt.Println(slice)  <span class="comment">// 打印 [10 20 30 40 50]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印 5</span></span><br><span class="line"><span class="comment">/* 创建一个新切片。</span></span><br><span class="line"><span class="comment">长度为 2，容量为 4。*/</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(slice)  <span class="comment">// 打印 [10 20 30 40 50]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice))  <span class="comment">// 打印 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice))  <span class="comment">// 打印 4</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*7g5CJ002CXIEo9iQn-Dp6A.png" alt="图 8：对切片进行切片。"></p>
<p>在执行切片操作之后，我们拥有两个共享同一底层数组的切片。然而，这两个切片以不同的方式查看底层数组。原始切片认为底层数组的容量为 5，但 newSlice 与之不同，对 newSlice 而言，底层数组的容量为 4。newSlice 无法访问位于其指针之前的底层数组元素。就 newSlice 而言，这些元素甚至并不存在。使用下面的方式可以为任意切片后的 newSlice 计算长度和容量。</p>
<h4 id="切片的长度与容量如何计算？"><a href="#切片的长度与容量如何计算？" class="headerlink" title="切片的长度与容量如何计算？"></a>切片的长度与容量如何计算？</h4><blockquote>
<p>切片 <strong>slice[i:j]</strong> 的<strong>底层数组容量为 k</strong><br>长度（Length）：j - i<br>容量（Capacity）：k - i</p>
</blockquote>
<p><strong>计算新的长度和容量</strong></p>
<blockquote>
<p>切片 <strong>slice[1:3]</strong> 的<strong>底层数组容量为 5</strong><br>长度（Length）：3 - 1 = 2<br>容量（Capacity）：5 - 1 = 4</p>
</blockquote>
<h4 id="对一个切片进行更改的结果"><a href="#对一个切片进行更改的结果" class="headerlink" title="对一个切片进行更改的结果"></a>对一个切片进行更改的结果</h4><p>一个切片对底层数组的共享部分所做的更改可以被另一个切片看到。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新的切片。</span></span><br><span class="line"><span class="comment">// 长度为 2，容量为 4。</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 变更新切片索引 1 位置的元素。</span></span><br><span class="line"><span class="comment">// 改变了原切片索引 2 位置的元素。</span></span><br><span class="line">newSlice[<span class="number">1</span>] = <span class="number">35</span></span><br></pre></td></tr></table></figure>
<p>将数值 35 分配给 newSlice 的第二个元素后，该更改也可以在原始切片的元素中被看到。</p>
<h4 id="运行时错误显示索引超出范围"><a href="#运行时错误显示索引超出范围" class="headerlink" title="运行时错误显示索引超出范围"></a>运行时错误显示索引超出范围</h4><p>一个切片只能访问它长度以内的索引位。尝试访问超出长度的索引位元素将引发一个运行时错误。与切片容量相关联的元素只能用于切片增长。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 5。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"><span class="comment">// 创建一个新的切片。</span></span><br><span class="line"><span class="comment">// 长度为 2，容量为 4。</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment">// 变更 newSlice 索引 3 位置的元素。</span></span><br><span class="line"><span class="comment">// 对于 newSlice 而言，该元素不存在。</span></span><br><span class="line">newSlice[<span class="number">3</span>] = <span class="number">45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Runtime Exception:</span></span><br><span class="line"><span class="comment">panic: runtime error: index out of range</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="切片增长"><a href="#切片增长" class="headerlink" title="切片增长"></a>切片增长</h4><p>与使用数组相比，使用切片的优势之一是：你可以根据需要增加切片的容量。当你使用内置函数 「append」 时，Golang 会负责处理所有操作细节。</p>
<ul>
<li>使用 append 前，你需要一个源<strong>切片</strong>和一个要追加的值。</li>
<li>当你的 append 调用并返回时，它将为你提供一个更改后的新切片。 </li>
<li><strong>append</strong> 函数总会增加新切片的长度。</li>
<li>另一方面，容量可能会受到影响，也可能不会受到影响，这取决于源切片的可用容量。</li>
</ul>
<h4 id="使用-append-向切片追加元素"><a href="#使用-append-向切片追加元素" class="headerlink" title="使用 append 向切片追加元素"></a>使用 append 向切片追加元素</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度和容量均为 5。 */</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个新切片。</span></span><br><span class="line"><span class="comment"> 长度为 2，容量为 4。*/</span></span><br><span class="line">newSlice := slice[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向容量空间分配新元素。</span></span><br><span class="line"><span class="comment"> 将值 60 分配给新元素。 */</span></span><br><span class="line">newSlice = <span class="built_in">append</span>(newSlice, <span class="number">60</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 3</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 4</span></span><br></pre></td></tr></table></figure>
<p>当切片的底层数组没有可用容量时，append 函数将创建一个新的底层数组，拷贝正在引用的现有值，然后再分配新值。</p>
<h4 id="使用-append-增加切片的长度和容量"><a href="#使用-append-增加切片的长度和容量" class="headerlink" title="使用 append 增加切片的长度和容量"></a>使用 append 增加切片的长度和容量</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(slice)) <span class="comment">// 打印 4</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(slice)) <span class="comment">// 打印 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向切片追加新元素。</span></span><br><span class="line"><span class="comment">// 将值 50 分配给新元素。</span></span><br><span class="line">newSlice= <span class="built_in">append</span>(slice, <span class="number">50</span>)</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(newSlice)) <span class="comment">// 打印 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(newSlice)) <span class="comment">// 打印 8</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn-images-1.medium.com/max/2000/1*GeiklLBspOlv_qxzw5GCVA.png" alt="图 9：增加切片的长度和容量"></p>
<p>在 append 操作后，newSlice 被给予一个自有的底层数组，该底层数组的容量是原底层数组容量的两倍。在增加底层数组容量时，append 操作十分聪明。举个例子，当切片的容量低于 1,000 个元素时，容量增长总是翻倍的。一旦元素的数量超过 1,000 个，容量就会增长 1.25 倍，即 25%。随着时间的推移，这种增长算法可能会在 Golang 中发生变化。</p>
<p>更改新切片不会对旧切片产生任何影响，因为新切片现在有一个不同的底层数组，它的指针指向一个新分配的数组。</p>
<h4 id="将一个切片追加到另一个切片中"><a href="#将一个切片追加到另一个切片中" class="headerlink" title="将一个切片追加到另一个切片中"></a>将一个切片追加到另一个切片中</h4><p>内置函数 <strong>append</strong> 还是一个 <strong>可变参数</strong> 函数。这意味着你可以传递多个值来追加到单个切片中。如果你使用 … 运算符，可以将一个切片的所有元素追加到另一个切片中。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建两个切片，使用两个整型元素初始化每个切片。</span></span><br><span class="line">slice1:= []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">slice2 := []<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// 合并两个切片并打印结果。</span></span><br><span class="line">fmt.Println(<span class="built_in">append</span>(slice1, slice2...))</span><br><span class="line"><span class="comment">// 输出：[1 2 3 4]</span></span><br></pre></td></tr></table></figure>
<h4 id="对切片执行索引"><a href="#对切片执行索引" class="headerlink" title="对切片执行索引"></a>对切片执行索引</h4><ul>
<li>通过指定一个下限和一个上限来形成切片，例如：<code>a[low:high]</code>。这将选择一个半开范围，其中包含切片的第一个元素，但不包含切片的最后一个元素。</li>
<li>你可以省略上限或下限，这将使用它们的默认值。下限的默认值是 0，上限的默认值是切片的长度。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; </span><br><span class="line"><span class="comment">// 一个数组</span></span><br><span class="line">s := a[<span class="number">1</span>:<span class="number">3</span>]               </span><br><span class="line"><span class="comment">// s == []int&#123;1, 2&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 3</span></span><br><span class="line">s = a[:<span class="number">2</span>]                 </span><br><span class="line"><span class="comment">// s == []int&#123;0, 1&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 4</span></span><br><span class="line">s = a[<span class="number">2</span>:]                 </span><br><span class="line"><span class="comment">// s == []int&#123;2, 3&#125;        </span></span><br><span class="line"><span class="comment">// cap(s) == 2</span></span><br><span class="line">s = a[:]                  </span><br><span class="line"><span class="comment">// s == []int&#123;0, 1, 2, 3&#125;  </span></span><br><span class="line"><span class="comment">// cap(s) == 4</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历切片"><a href="#遍历切片" class="headerlink" title="遍历切片"></a>遍历切片</h4><p>Go 有一个特殊的关键字 <strong>range</strong>，你可以使用该关键字对切片进行遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 遍历每个元素并打印值。</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Index: 0 Value: 10</span></span><br><span class="line"><span class="comment">Index: 1 Value: 20</span></span><br><span class="line"><span class="comment">Index: 2 Value: 30</span></span><br><span class="line"><span class="comment">Index: 3 Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在遍历切片时，关键字 range 将返回两个值。</li>
<li>第一个值是索引下标，第二个值是索引位中值的副本。</li>
<li>一定要知道 range 是在复制值，而不是返回值的引用。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 创建一个整型切片。</span></span><br><span class="line"><span class="comment"> 长度与容量均为 4。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 遍历每个元素并打印</span></span><br><span class="line"><span class="comment"> 元素的值和地址。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Value: %d Value-Addr: %X ElemAddr: %X\n"</span>,</span><br><span class="line">   value, &amp;value, &amp;slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Value: 10 Value-Addr: 10500168 ElemAddr: 1052E100</span></span><br><span class="line"><span class="comment">Value: 20 Value-Addr: 10500168 ElemAddr: 1052E104</span></span><br><span class="line"><span class="comment">Value: 30 Value-Addr: 10500168 ElemAddr: 1052E108</span></span><br><span class="line"><span class="comment">Value: 40 Value-Addr: 10500168 ElemAddr: 1052E10C</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><strong>range</strong> 关键字提供元素的拷贝。</p>
<p>如果你不需要下标值，你可以使用下划线字符丢弃该值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a slice of integers.</span></span><br><span class="line"><span class="comment">// Contains a length and capacity of 4 elements.</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// Iterate over each element and display each value.</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> slice &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Value: %d\n"</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Output:</span></span><br><span class="line"><span class="comment">Value: 10</span></span><br><span class="line"><span class="comment">Value: 20</span></span><br><span class="line"><span class="comment">Value: 30</span></span><br><span class="line"><span class="comment">Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>关键字 <strong>range</strong> 总是从开始处遍历一个切片。如果你需要对切片的迭代进行更多的控制，你可以使用传统的 <strong>for</strong> 循环。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个整型切片。</span></span><br><span class="line"><span class="comment">// 长度和容量均为 4。</span></span><br><span class="line">slice := []<span class="keyword">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line"><span class="comment">// 从元素 30 开始遍历每个元素。</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">2</span>; index &lt; <span class="built_in">len</span>(slice); index++ &#123;</span><br><span class="line">   fmt.Printf(<span class="string">"Index: %d Value: %d\n"</span>, index, slice[index])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">Index: 2 Value: 30</span></span><br><span class="line"><span class="comment">Index: 3 Value: 40</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在本文中，我们深入探讨了切片的概念。我们了解到，切片并不存储任何数据，而是描述了底层数组的一部分。我们还看到，切片可以在底层数组的范围内增长和收缩，并配合索引可作为数组使用；切片的零值是 nil；函数 <strong>len</strong>、<strong>cap</strong> 和 <strong>append</strong> 都将 <strong>nil</strong> 看作一个长度和容量都为 0 的<strong>空切片</strong>；你可以通过<strong>切片字面量</strong>或调用 <strong>make</strong> 函数（将长度和容量作为参数）来创建切片。希望这些对你有所帮助！</p>
<p><strong>免责声明</strong></p>
<p>我参考了各种博客、书籍和媒体故事来撰写这篇文章。如有任何疑问，请在评论中与我联系。</p>
<p><strong>到此为止……开心编码……快乐学习😃</strong></p>
<blockquote>
<p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p>
</blockquote>
<hr>
<blockquote>
<p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p>
</blockquote>
</div><iframe src="/donate/?AliPayQR=/img/AliPayQR.jpeg&amp;WeChatQR=/img/WeChatQR.jpeg&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>江五渣。欢迎关注我的公众号：「编程拯救世界」，在编程世界一起冒险，一起成长！</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/">http://jalan.space/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 知识共享署名 3.0，可自由转载、引用，但需署名作者且注明文章出处。</li></ul></div><br><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a class="article-share-link" data-url="http://jalan.space/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/" data-id="ckr8u2jet00d85n7ustajhq4l" data-qrcode="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuUlEQVR42u3aMXLcMBAEQP3/01LiwCqZp5ldwHVBM2KpeCCaAQDN7sdHfH2+vJ6e/PsvP595un8a/+c4xy48PDy8C1N/wrwm5dT27fnnxsPDw7vHe5r06/vN86+R+fi/WPDw8PDegLc/cOeH79mTeHh4eO/GaxfxZLotCQ8PD+8deG2E2oaqSdCwCTsOZC14eHh4MS+f3PvcX6nv4eHh4a2r6rMl+2zoMJvnnxHw8PDwLvBmBapk29gcoDeHeDw8PLzbvE0Q0Ea3LWPWevVtTDw8PLwLvHwJbptK26nMguNom8HDw8O7zEsK9u1U2iaDU6U1PDw8vBu82UA5ab+sr47veHh4eBd4ebV9c1Ktd6ogesgP+nh4eHi3ee1Cn28PSVTRFrpWWwUeHh7empdMtx06+Sh5/NGWwfDw8PBu8GaD5st9cvCdRRLRzPHw8PAu8PLXn1rWN3FD+0Hx8PDwbvPaeGIWHLRNCW1Esqry4eHh4cXZZl5tb8tOmyfbaGPYdIWHh4dX8mYL7qxNalMSazebf/wWDw8P7xBvEy7k5f+87SCPjKNDOR4eHt4F3uZgPdsqZg0KbeRxIJLAw8PDe3gmPzrPDrvJgn4gh8bDw8P777w2Qt2Etu0nSzaSX3Y8PDw8vKO8tsC/aUHIP1xSeKubD/Dw8PCO8tqAII9oN1tF/t6o9QoPDw/vAi9ZjttlOge0sXIxMh4eHt413izSnR1/20aE9oqO1Hh4eHgj3md55UHqLJjYbwOPPWV4eHh4h3j7oWfH3zw43ofLeHh4eDd4edjatg7Mzviz8aMCGB4eHt5RXl7Un20AbVRxIGXBw8PDe2NeXiTLt4R9CxceHh7eu/GKF8S/apsY6s4IPDw8vKO8WVNpUhibtaImDQrRW/Dw8PAu8Gb/5O/LV3lYfKMRAQ8PD2/E+wLMlCC1EUp+kgAAAABJRU5ErkJggg==">分享</a><div class="tags"><a href="/tags/翻译/">翻译</a><a href="/tags/设计模式/">设计模式</a></div><div class="post-nav"><a class="pre" href="/2020/10/30/2020/wx-miniprogram-tabbar/">微信小程序自定义 tabBar 踩坑实践</a><a class="next" href="/2020/09/01/2020/mysql-using-index/">MySQL 覆盖索引与延迟关联</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://jalan.space/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/';
    this.page.identifier = '2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/';
    this.page.title = '【译】Golang 切片综合指南';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//jalanspace.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//jalanspace.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://jalanspace.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"><input type="hidden" name="sitesearch" value="http://jalan.space"></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Web屠龙刀/">Web屠龙刀</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/云原生应用/">云原生应用</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/少年人的冲动/">少年人的冲动</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/技多不压身/">技多不压身</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/磨刀石/">磨刀石</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/移动开发者/">移动开发者</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/跨过这道坎/">跨过这道坎</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/jekyll/" style="font-size: 15px;">jekyll</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/影评/" style="font-size: 15px;">影评</a> <a href="/tags/meitu/" style="font-size: 15px;">meitu</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/Bootstrap/" style="font-size: 15px;">Bootstrap</a> <a href="/tags/matlab/" style="font-size: 15px;">matlab</a> <a href="/tags/图像处理/" style="font-size: 15px;">图像处理</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Shell/" style="font-size: 15px;">Shell</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Laravel/" style="font-size: 15px;">Laravel</a> <a href="/tags/生活啊/" style="font-size: 15px;">生活啊</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/macOS/" style="font-size: 15px;">macOS</a> <a href="/tags/网络爬虫/" style="font-size: 15px;">网络爬虫</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Kubernetes/" style="font-size: 15px;">Kubernetes</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/mongodb/" style="font-size: 15px;">mongodb</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/GCP/" style="font-size: 15px;">GCP</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/Composer/" style="font-size: 15px;">Composer</a> <a href="/tags/Lumen/" style="font-size: 15px;">Lumen</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/GraphQL/" style="font-size: 15px;">GraphQL</a> <a href="/tags/Shadowsocks/" style="font-size: 15px;">Shadowsocks</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/数据结构/" style="font-size: 15px;">数据结构</a> <a href="/tags/docsify/" style="font-size: 15px;">docsify</a> <a href="/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/tags/SQL/" style="font-size: 15px;">SQL</a> <a href="/tags/开发规范/" style="font-size: 15px;">开发规范</a> <a href="/tags/OAuth/" style="font-size: 15px;">OAuth</a> <a href="/tags/WeChat/" style="font-size: 15px;">WeChat</a> <a href="/tags/开发者大会/" style="font-size: 15px;">开发者大会</a> <a href="/tags/操作系统/" style="font-size: 15px;">操作系统</a> <a href="/tags/Swift/" style="font-size: 15px;">Swift</a> <a href="/tags/iOS/" style="font-size: 15px;">iOS</a> <a href="/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/tags/面向对象/" style="font-size: 15px;">面向对象</a> <a href="/tags/DevOps/" style="font-size: 15px;">DevOps</a> <a href="/tags/源码阅读/" style="font-size: 15px;">源码阅读</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/No-SQL/" style="font-size: 15px;">No-SQL</a> <a href="/tags/网络/" style="font-size: 15px;">网络</a> <a href="/tags/小程序/" style="font-size: 15px;">小程序</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/11/2021/go-source-code-muluiniptr/">Go 源码阅读：内存分配前的溢出判断</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/19/2020/what-is-wsgi/">【译】给初学者的示例：什么是 WSGI？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/30/2020/wx-miniprogram-tabbar/">微信小程序自定义 tabBar 踩坑实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/14/2020/a-comprehensive-guide-to-slices-in-golang/">【译】Golang 切片综合指南</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/01/2020/mysql-using-index/">MySQL 覆盖索引与延迟关联</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/05/05/2020/variable-percision-swar/">Redis 中的 variable-precision SWAR 算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/30/2020/design-pattern-observer/">《Head First 设计模式》学习笔记 | 观察者模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/29/2020/decouple-your-code-with-dependency-injection/">【译】用依赖注入解耦你的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/09/2020/design-pattern-strategy-pattern/">《Head First 设计模式》学习笔记 | 策略模式</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/25/2020/is-no-sql-killing-sql/">【译】SQL 将死于 No-SQL 之手？</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//jalanspace.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://blog.w2fzu.com/" title="西二在线" target="_blank">西二在线</a><ul></ul><a href="http://www.hongweipeng.com/" title="栖迟於一丘" target="_blank">栖迟於一丘</a><ul></ul><a href="http://shixiong.name/" title="Daemon" target="_blank">Daemon</a><ul></ul><a href="http://csming1995.github.io/" title="Csming's world" target="_blank">Csming's world</a><ul></ul><a href="https://mychiaki.github.io/" title="Chiaki" target="_blank">Chiaki</a><ul></ul><a href="http://www.ruphi.cn/" title="ruphi" target="_blank">ruphi</a><ul></ul><a href="http://lizimeow.cn/" title="栗子膜法师" target="_blank">栗子膜法师</a><ul></ul><a href="https://evaaaaaaaxiao.github.io/" title="Eva.X" target="_blank">Eva.X</a><ul></ul><a href="http://gagalee.ink/" title="185大总攻嘎嘎大人" target="_blank">185大总攻嘎嘎大人</a><ul></ul><a href="https://woodenrobot.me/" title="WoodenRobot's Blog" target="_blank">WoodenRobot's Blog</a><ul></ul><a href="https://imiku.me" title="冰凌胧月的小窝" target="_blank">冰凌胧月的小窝</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">忘归.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>